{"stage":3,"title":"Автоматизация работы через НПМ и Галп","subTitle":"Технологии нужны для автоматизации процессов, поэтому в этом уроке мы учимся работе со скриптам в Нпме и Галпу","markdown":"> Если вы не знаете Джаваскрипт, то в [курсе по Реакту](https://erodionov.ru/courses/react) пройдите третий урок, «Джаваскрипт для начинающих». Он открытый. Да и остальные тоже полезными будут!\n\nС Нпмом вы уже знакомы по четырнадцатому уроку с Постцсс и знаете про работу с **пакетами**.\n\nПакеты бывают двух типов: **исполняемые** (или бинарники) и **подключаемые**. Нас интересуют первые — вторые понадобятся в [курсе по Реакту](https://erodionov.ru/courses/react).\n\n## Исполняемые пакеты в Нпме\n\nВ Нпме полно пакетов, которые можно запустить в Терминале. Ключевое отличие от Хоумбрю или другого системного пакетного менеджера в том, что почти всегда пакеты в Нпме написаны на Джаваскрипте, а поэтому благодаря Ноде запускаются на любой системе без особых правок.\n\nОбычно эти пакеты имеют постфикс [`-cli`](https://www.npmjs.com/search?q=keywords:cli) (command line interface).\n\n_Кстати, вы же не забыли, что говоря Нпм, мы подразумеваем базу Нпма, с которой мы будем работать через Ярн?_\n\nПримеры?\n\n* [postcss-cli](http://npm.im/postcss-cli) — уже знакомый ПостЦСС,\n* [html-minifier](http://npm.im/html-minifier) — минификатор ХТМЛ,\n* [uglify-js](https://www.npmjs.com/package/uglify-js) — минификатор и оптимизатор Джса,\n* [pa11y](https://www.npmjs.com/package/pa11y) — тестировщик a11y,\n* [stylelint](https://www.npmjs.org/package/stylelint) — линтер стилей,\n* и даже [git-open](https://www.npmjs.com/package/git-open) — команда для открытия Гитхаба или других сервисов из консоли.\n\n_Линтер, кстати, это анализатор кода на предмет проблем_\n\nОкей, эти пакеты мы и так умеем запускать через `yarn postcss ...` или `yarn pa11y ...`, а причём тут Нпм?\n\nВ нпмовском `package.json` есть поле [`scripts`](https://docs.npmjs.com/misc/scripts): это Джаваскриптовский объект, где можно написать скрипты, которые вы потом будете запускать через `yarn run ...`.\n\nПример:\n\n```json\n{\n  \"name\": \"erodionov.ru\",\n  \"scripts\": {\n    \"minify:html\": \"html-minifier --input-dir src --output-dir dist\",\n    \"minify:css\": \"csso --input src/styles.css --output dist/styles.css\",\n    \"minify\": \"yarn run minify:html && yarn run minify:css\",\n    \"lint\": \"stylelint src\"\n  }\n}\n```\n\nЗачем это вообще нужно?\n\n**Во-первых**, команды можно комбинировать через `&&` — вместо 10 команд вы можете запускать одну. На самом деле, оператор `&&` — системный, поэтому это не особо аргумент.\n\n**Во-вторых**, эти скрипты работают как альясы: вместо того, чтобы писать огромные команды с кучей флагов, вы всё сводите к `yarn run X`. Вот это действительно удобно!\n\n---\n\nНо что делать, если команд становится **очень** много? Штук 50 не очень хочется поддерживать, верно? Для этого существует [Галп](https://gulpjs.com/).\n\n## Галп\n\nГалп это утилита, которая автоматизирует **воркфлоу** (рабочий процесс) через **таски** (задачи).\n\nЧасто звучит мысль о том, что Галп не нужен — во фронтэнде это правда, почти во всех задачах его заменил [Вебпак](https://webpack.js.org/) (мы рассматриваем его в [курсе по Реакту](https://erodionov.ru/courses/react)), а с остальным справляются Нпм-скрипты. Тем не менее, в вёрстке нет Вебпака, поэтому тут спокойно используют Галп.\n\nТаски (`task`) в Галпе очень простые: на вход (`in`) подаётся исходник (`src`), мы его преобразовываем (`pipe`), на выходе (`out`) мы получаем результат (`dest`).\n\nГалп, кстати, работает на своих плагинах, поэтому вам нужны специальные версии: модуль `csso` не подойдёт, нужен `gulp-csso`). То же самое с Постцссом: нужен [`gulp-postcss`](https://github.com/postcss/gulp-postcss). Гуглите `gulp [нужный модуль]`.\n\nСмотрите, вот как это выглядит в коде:\n\n```js\n// gulpfile.js\n\nconst gulp = require(\"gulp\"); // подключаем Галп как модуль\nconst minifycss = require(\"gulp-csso\");\nconst postcss = require(\"gulp-postcss\");\n\n// плагины для ПостЦСС\nconst autoprefixer = require(\"autoprefixer\");\nconst cssnext = require(\"cssnext\");\n\n// объявляем таск с названием \"styles\"\n// первым аргументом — название таска,\n// вторым — функция, которая возвращает (`return`),\n// обработанным\ngulp.task(\"styles\", function() {\n  return gulp\n    .src(\"src/styles/*.css\") // через .src() передаём путь до исходника\n    .pipe(postcss([cssnext(), autoprefixer()])) //  через .pipe() вызываем плагин как функцию\n    .pipe(minifycss()) // и ещё раз\n    .pipe(gulp.dest(\"build/styles\")); // в финальном пайпе через gulp.dest() указываем куда сложить результат\n});\n```\n\nВ документации Галпа есть крутые [рецепты](https://github.com/gulpjs/gulp/tree/v3.9.1/docs/recipes), описание [АПИ](https://github.com/gulpjs/gulp/blob/v3.9.1/docs/API.md), и [плагины](https://gulpjs.com/plugins/). А я попробую ответить на возникшие вопросы.\n\n#### Как запускать-то?\n\nВо-первых, `gulp-cli` должен быть установлен в проекте.\n\nВо-вторых, как и любой исполняемый пакет — `yarn gulp [название таска]`.\n\n#### Как объединить таски?\n\nВторым аргументом функции `.task()` передайте массив других тасков, а не функцию. Пример есть на [главной странице](https://gulpjs.com/) Галпа.\n\n```js\ngulp.task(\"build\", [\"styles\", \"scripts\", \"images\"]);\n```\n\nВажно: все таски будут запускать параллельно, а не последовательно.\n\n#### Тогда как запустить последовательно?\n\nОтвет в документации: [Running tasks in series, i.e. Task Dependency](https://github.com/gulpjs/gulp/blob/v3.9.1/docs/recipes/running-tasks-in-series.md)\n\n#### Устал постоянно запускать Галп\n\nМожно воспользоваться [`gulp.watch`](https://github.com/gulpjs/gulp/blob/v3.9.1/docs/API.md#gulpwatchglob--opts-tasks-or-gulpwatchglob--opts-cb) по аналогии с `gulp.task()`: первым аргументом название (например, `'watch-js'`), вторым — массив из тасков.\n\nГалп будет держать процесс открытым и запускать таски, если что-то изменилось в исходниках.\n\n#### Он постоянно собирает всё заново и поэтому работает медленно\n\nЭто можно исправить инкрементальным обновлением (incremental update) через [`gulp-watch`](https://github.com/floatdrop/gulp-watch), рецепт есть, опять же, в документации: [Rebuild only files that change](https://github.com/gulpjs/gulp/blob/v3.9.1/docs/recipes/rebuild-only-files-that-change.md).\n\n## Задание\n\nДля начала вам нужно разделить проект на две директории: `src` и `build`. В первой будут исходники, во второй — обработанные файлы.\n\nНе забудьте, что `build` не должна быть в репозитории — воспользуйтесь `.gitignore`.\n\nВот задания:\n\n* перенесите работу с ПостЦСС в Галп,\n* подключите какой-нибудь оптимизатор картинок,\n* подключите минифайеры ХТМЛ и ЦСС,\n* подключите [Стайлинт](https://stylelint.io/) (конфигом возьмите [stylelint-config-standard](https://github.com/stylelint/stylelint-config-standard)) — вы должны знать об ошибках,\n* объедините это под таском `build`,\n* а для собственного удобства заведите таск `watch`.\n\nЧтобы было проще работать с Джаваскриптом, поставьте в редактор [Преттир](https://prettier.io/) — это форматтер кода — и [Еслинт](http://eslint.org/) (с конфигом [eslint-config-recommended](http://npm.im/eslint-config-recommended)) — это валидатор кода, он будет подсвечивать ошибки чтобы вы их исправляли ещё до запуска Галпа Нодой.\n\n## Итог\n\nВ этом уроке мы разобрались с автоматизацией процессов через Нпм-скрипты и Галп.\n\nВопреки слухам, Галп живее всех живых и всё ещё помогает верстальщикам спасаться от боли ручной работы.\n\nКстати, есть ещё один популярный таск раннер — [Грант](https://gruntjs.com/). Галп настраивается кодом на Джаваскрипте, а [Гранта](https://gruntjs.com/sample-gruntfile) программируется конфигами. Плюс работает медленнее (потому что Галп работает с памятью, а Грант с файлами), ну и заброшен сообществом давным-давно.\n","previous":["Z85TwJEQNd","nHdviS9Jil","kK6TqBobfl","Wfn3j53w5G","vUP7iRK2my","mGpNZTKciZ","DNmsGGToly","iZzoQdvKTy","dXE2elcH7C","4ipvf7K5px","79Mt7wYOrs","7KIkWf2nMt","ypIwD9OkNU","KEZTmbshEY","BxVTHC2RI5"],"id":"Qf6hOneMdp","stageId":"WxcdGfFHO1"}