{"stage":3,"title":"Паттерны: от Higher-Order Components до Render Props","subTitle":"Вместо собственных велосипедов давайте использовать уже готовые подходы","markdown":"# Паттерны Реакта\n\n> Вместо собственных велосипедов давайте использовать уже готовые подходы\n\n## [Conditional Rendering](https://reactjs.org/docs/conditional-rendering.html)\n\nНачнём, на удивление, с самого простейшего вопроса: как отрендерить кусок в зависимости от проверки?\n\nКак вы помните, Джсх это всё равно что Джс, поэтому в самом примитивном варианте просто вставьте ифы и ретёрны.\n\n### Примитивный вариант\n\n```jsx\nif (x) return <TruthyComp />;\n\n// вернется если проверка на x\n// не отработала в true\nreturn <FalsyComp />;\n```\n\nНу или тернарный оператор `?:`\n\n```jsx\nreturn x ? <TruthyComp /> : <FalsyComp />;\n```\n\n### [Инлайновые проверки](https://reactjs.org/docs/conditional-rendering.html#inline-if-with-logical--operator)\n\nЧто делать, если у вас большой компонент (не надо так) и нужно по условию отрендерить какой-то блок? Допустим, кнопку. Просто поместите проверку через оператор `&&` в `{}`.\n\n```jsx\nfunction Mailbox(props) {\n  const unreadMessages = props.unreadMessages;\n  return (\n    <div>\n      <h1>Hello!</h1>\n      {unreadMessages.length > 0 && (\n        <h2>You have {unreadMessages.length} unread messages.</h2>\n      )}\n    </div>\n  );\n}\n```\n\nКак замечено в официальной документации, такое возможно, потому что в Джаваскрипте выражение `true && expression` выполнит `expression`, а `false && expression` выполнит `false`.\n\n## Частичные компоненты\n\nСоздаёте компонент вокруг другого компонента, передав ему какой-то набор пропов.\n\n```jsx\nconst Button = props =>\n  <button type=\"button\" {...props}>\n\n<Button />\n// <button type=\"button\"><button>\n\n<Button className=\"CTA\">Send Money</Button>\n// <button type=\"button\" class=\"CTA\">Send Money</button>\n```\n\n## [Children-as-a-function или render prop](https://reactjs.org/docs/render-props.html)\n\nЧилдрен может быть функцией. Знали?\n\n```jsx\nclass Auth extends React.Component {\n  state = {\n    isLoggedIn: false,\n    userId: 1\n  };\n\n  render() {\n    const { isLoggedIn, userId } = this.state;\n\n    return this.props.children({ isLoggedIn, userId });\n  }\n}\n\nfunction Lesson(props) {\n  return (\n    <View>\n      <h1>{props.title}</h1>\n\n      <Auth>\n        {function({ isLoggedIn, userId }) {\n          if (isLoggedIn) {\n            return props.lesson;\n          }\n\n          // возвращаем превью урока если человек не залогинен\n          return props.preview;\n        }}\n      </Auth>\n    </View>\n  );\n}\n```\n\nТот же самый паттерн используется в [рендер пропе](https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce): просто вместо чилдрен используется проп `render` и код выглядит как `<Auth render={function() {...}} />`.\n\n## [Higher-order Component](https://reactjs.org/docs/higher-order-components.html)\n\nЕщё один способ передать пропы из одного компонента в другой: HoC.\n\nHoC — это функция, в которую приходит компонент и которая возвращает другой компонент.\n\nИз примеров: `connect()` в react-redux и `withRouter()` в Реакт-роутере.\n\n```jsx\nfunction withAuth(Comp, options = {}) {\n  return class extends React.Component {\n    state = {\n      isLoggedIn: false,\n      userId: 1\n    };\n\n    render() {\n      const { isLoggedIn, userId } = this.state;\n\n      return <Comp isLoggedIn={isLoggedIn} userId={userId} />;\n    }\n  };\n}\n\nfunction Lesson(props) {\n  return (\n    <View>\n      <h1>{props.title}</h1>\n\n      {this.props.isLoggedIn ? props.lesson : props.preview}\n    </View>\n  );\n}\n\nconst LessonWithAuth = withAuth(Lesson);\n```\n\nВ чём отличие от рендер пропа? В том, что менее явное поведение: в рендер пропе обычная функция с набором аргументов, а тут в пропы нашего компонента спускаются неизвестные пропы.\n\n## Родитель-ребенок\n\nЗдесь оставлю ссылку на [пост](https://medium.com/@jmuse/d86394da2b50) Юли, которая проходила курс: она расписала модели «родитель → ребенок», «ребенок → родитель» и «ребенок → ребенок».\n\n## Итог\n\nПаттерны нужны, чтобы не плодить свои велосипеды и не усложнять себе (и другим разработчикам!) жизнь.\n\nИспользуйте всё кроме HoC — за лаконичность их АПИ расплачиваетесь неочевидностью пропов.\n","id":"nxvBdqk3uu","stageId":"tHKYMIR4QG"}