{"stage":3,"title":"Про Вебпак, Бейбель, Еслинт без create-react-app","subTitle":"Разбираемся в тех технологиях, о которых ходят слухи, что они сложные","markdown":"Сегодня мы разберёмся с тем, как устроен create-react-app под собой.\n\n## Еслинт\n\nОкей, мы поставили преттир и настроили Еслинт на работу с дефолтным конфигом CRA ([`eslint-config-react-app`](https://www.npmjs.com/package/eslint-config-react-app)).\n\n[Еслинт](https://eslint.org/) это утилита, которая анализирует ваш код по заданным правилам.\n\nРаботает он сам по себе легко: вы ставите `eslint` как зависимость и в [файле конфига](https://eslint.org/docs/user-guide/configuring) задаёте настройки, по которым он работает.\n\nНастроек много, но нас интересуют три: правила (`rules`), плагины (`plugins`) и расширение через готовый конфиг (`extends`).\n\n### Правила\n\nОснова Еслинта это правила: вы указываете готовое правило ([список из дефолтных](https://eslint.org/docs/rules/)) и как Еслинту нужно себя вести.\n\n#### Показываем неиспользуемые значения\n\nПример: вы пишите код и хотите знать когда у вас остался мусор — вы объявили какую-нибудь константу или функцию, но не используете её. За это отвечает правило [no-unused-vars](https://eslint.org/docs/rules/no-unused-vars) (уточню, что `vars` тут в контексте слова `variables`, а не `var` из Джса).\n\nВы создаёте [`.eslintrc.json`](https://eslint.org/docs/user-guide/configuring#configuration-file-formats) и там прописываете это правило:\n\n```json\n{\n  \"rules\": {\n    \"no-unused-vars\": \"error\"\n  }\n}\n```\n\n`\"error\"` означает что это грубая ошибка. Бывает ещё `\"off\"` и `\"warn\"`.\n\n#### Запретим использовать `var`\n\nВ ES6 (он же ES2015) — версия стандарта ECMAScript, по которому работает Джс — добавили `let` и `const`.\n\nКак вы помните из второго урока, отличие в том, что `const` это неизменяемое значение, а у `let` область видимости ограничена блоком, где она объявлена (но при этом переопределять можно).\n\nМы не хотим использовать `var`, поэтому нам поможет правило [`no-var`](https://eslint.org/docs/rules/no-var).\n\nВ `.eslintrc.json` дописываем\n\n```diff\n{\n  \"rules\": {\n    \"no-unused-vars\": \"error\",\n+   \"no-var\": \"error\"\n  }\n}\n```\n\n### Плагины\n\nНо как запретить использовать и `let` тоже? Для этого есть плагин [`eslint-plugin-fp`](https://github.com/jfmengels/eslint-plugin-fp), он форсит функциональное программирование, в том числе и иммутабельность.\n\nПлагины подключаются легко: ставите как зависимость, потом в `.eslintrc.json` прописываете поле `plugins` с массивом используемых плагинов, а в `rules` — правило, где префиксом будет название плагина. Щас покажу!\n\n```diff\n{\n+ \"plugins\": [\"fp\"],\n  \"rules\": {\n    \"no-unused-vars\": \"error\",\n    \"no-var\": \"error\",\n+   \"fp/no-let\": \"error\"\n  }\n}\n```\n\n_(кстати, в перечислении плагинов можно опустить префикс `eslint-plugin-` и оставить только `fp`)_\n\nЕсть [очень много плагинов](https://www.npmjs.com/browse/keyword/eslintplugin), например, [`eslint-plugin-react`](https://www.npmjs.com/package/eslint-plugin-react) который отвечает за работу с Реактом или [`eslint-plugin-import`](https://www.npmjs.com/package/eslint-plugin-import) который смотрит за импортами.\n\n### Готовые конфиги\n\nНо Женя, неужели это всё руками прописывать надо? Огромные же конфиги получаются, плюс Еслинт и плагины обновляются, правила добавляются, мне что, за этим следить постоянно?\n\nСлава богу нет! У многих плагинов есть рекомендуемая конфигурация, как и у Еслинта. Использование поля `extends` описано в [документации](https://eslint.org/docs/user-guide/configuring#extending-configuration-files).\n\nЭкстендить можно только несколько конфигов, например, можно взять `eslint:recommended`, `plugin:fp/recommended` и `plugin:react/recommended`:\n\n```diff\n{\n  \"plugins\": [\"fp\", \"react\"],\n+ \"extends\": [\n+   \"eslint:recommended\",\n+   \"plugin:fp/recommended\",\n+   \"plugin:react/recommended\"\n+ ],\n  \"rules\": {\n    \"no-unused-vars\": \"error\",\n    \"no-var\": \"error\",\n    \"fp/no-let\": \"error\"\n  }\n}\n```\n\nПри этом правила, которые объявлены в `rules`, будут перебивать те, что указаны в самих конфигах.\n\n#### Конфиг от Эйрбнб\n\nЭйрбнб очень много вкладываются в опенсорс и много лет назад [написали популярный стайлгайд по Джаваскрипту](http://github.com/airbnb/javascript) — советую его прочитать.\n\nЧто такое стайлгайд? Это правила. С чем работает еслинт? С правилами. В итоге ребята сделали свой конфиг по этому стайлгайду: [`eslint-config-airbnb`](https://www.npmjs.com/package/eslint-config-airbnb).\n\nОн самый жёсткий из всех: ваш код будет на 99% красным, но зато он будет самым красивым и правильным из всех, что когда-либо показывали на откликах и собеседованиях ❤️\n\nЖизнь без Преттира и Еслинта:\n![](https://i.imgur.com/7nJRNtl.png?1)\n\n### Поле `parser` и Бейбель\n\nКогда вы поставите конфиг от Эйрбнб, Еслинт может сломаться и начать выдавать `unexpected token =` и другие ошибки. За это отвечает парсер — Еслинт не может спарсить (проанализировать) ваш код.\n\nПо-умолчанию Еслинт использует [Espree](https://github.com/eslint/espree), но он не обновлялся долгое время и поэтому не поддерживает ES6 и другие нововведения Джаваскрипта (помните про [`babel-plugin-transform-class-properties`](https://babeljs.io/docs/plugins/transform-class-properties/)?). Но, к счастью, парсер в Еслинте можно сменить через поле `parser`, вам понадобится [`babel-eslint`](https://github.com/babel/babel-eslint).\n\nКак вы понимаете, использовать легко: ставите как зависимость, указываете в поле `parser`\n\n```diff\n{\n+ \"parser\": \"eslint\",\n  \"plugins\": [\"fp\", \"react\"],\n  \"extends\": [\n    \"eslint:recommended\",\n    \"plugin:fp/recommended\",\n    \"plugin:react/recommended\"\n  ],\n  \"rules\": {\n    \"no-unused-vars\": \"error\",\n    \"no-var\": \"error\",\n    \"fp/no-let\": \"error\"\n  }\n}\n```\n\n## Бейбель\n\nКстати, о Бейбеле мы ещё не говорили.\n\n[Бейбель](http://babeljs.io/) это компилятор Джаваскрипта в Джаваскрипт.\n\nЕсли вы проходили [курс по вёрстке](https://erodionov.ru/verstka), то там есть урок про ПостЦСС и [cssnext](http://cssnext.io/) — способ писать будущий ЦСС уже сегодня. Достигается это за счёт того, что новый код превращается в старый с помощью ПостЦСС.\n\nБэйбель работает так же: вы пишите современный код (но который не поддерживают браузеры), прогоняете его Бейбелем и получаете тот, что поддерживается браузером.\n\n_Хотите узнать как работают компиляторы? Почитайте [The Super Tine Compiler](https://github.com/thejameskyle/the-super-tiny-compiler)._\n\nПомните, в третьем уроке мы говорили про JSX и что это всего лишь синтаксический сахар и на самом деле Реакт построен на методах `React.createElement()`? Именно этим и занимается Бейбель и плагин [`babel-plugin-transform-react-jsx`](https://babeljs.io/docs/plugins/transform-react-jsx/): превращает удобный для вас JSX в понятный браузеру `React.createElement()`. [Попробуйте в REPL](http://babeljs.io/repl).\n\n```jsx\n// input\nimport React from \"react\";\n\nconst HelloWorld = () => <div>Hello, world</div>;\n\n<HelloWorld />;\n\n// output\n(\"use strict\");\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : { default: obj };\n}\n\nvar HelloWorld = function HelloWorld() {\n  return _react2.default.createElement(\"div\", null, \"Hello, world\");\n};\n\n_react2.default.createElement(HelloWorld, null);\n```\n\nУ Бейбеля есть [много плагинов](http://babeljs.io/docs/plugins/), но, как и Еслинт, есть готовые пакеты — они называются пресетами (`preset`).\n\nРаньше были популярны `stage-*`-пресеты, но потом от них решили отказаться в пользу [`babel-preset-env`](http://babeljs.io/docs/plugins/preset-env/).\n\nЧто за стейджи? Стандарт Джаваскрипта (ECMAScript) развивается, им занимается комитет TC39. Работает он так: кто-то описывает новую функциональность в Джаваскрипте, кидает пропозал (proposal), комитет обсуждает на одной из встречи и двигает по стейджам: от 0 (самый сырой черновик) до 4 (вошло в стандарт). Список всех текущих пропозалов можно увидеть в репозитории [tc39/proposals](https://github.com/tc39/proposals).\n\nНапример, в стандарте [уже](https://github.com/tc39/proposals/blob/master/finished-proposals.md) есть [`Array.prototype.includes`](https://github.com/tc39/Array.prototype.includes), [async функции](https://github.com/tc39/ecmascript-asyncawait), [методы `Object.entries()` и `Object.values()`](https://github.com/tc39/proposal-object-values-entries) и другие.\n\nРаз они есть в стандарте — браузеры должны реализовать, но мы же не можем так долго ждать, нам нужно писать код с этими фичами уже сегодня! Для этого и существуют плагины Бейбеля, например, [`babel-plugin-array-includes`](https://www.npmjs.com/package/babel-plugin-array-includes).\n\nНа самом деле, этот блок про Бейбель чисто теоретический: в CRA он настолько хорошо настроен, что вам вряд ли придётся с ним столкнуться.\n\nCRA использует собственный пресет [`babel-preset-react-app`](https://github.com/facebook/create-react-app/tree/master/packages/babel-preset-react-app), куда уже включены плагины [`babel-plugin-transform-object-rest-spread`](http://babeljs.io/docs/plugins/transform-object-rest-spread/) и [`babel-plugin-transform-react-jsx`](http://babeljs.io/docs/plugins/transform-react-jsx/), но если бы вы хотели написать свой конфиг, то ваш `.babelrc` выглядел бы так:\n\n```json\n{\n  \"plugins\": [\"transform-object-rest-spread\", \"transform-react-jsx\"]\n}\n```\n\n_(как и у Еслинта, префикс `babel-plugin-` можно опустить)_\n\nКак видите, ничего сложного. Но что делать потом? Вам нужно скомпилировать ваш исходник в джс, который понятен браузеру.\n\nПоставьте `babel-cli` и запустите его как `yarn run babel [src] -d [dest]`, где `src` это директория с исходниками, а `dest` это куда нужно скопировать результат. Пример: `yarn run babel src -d build`.\n\nВсем этим (и другим) занимается Вебпак.\n\n## Вебпак\n\n[Вебпак](http://webpack.js.org/) — это бандлер модулей. В какой-то момент создатель Вебпака подумал: а зачем нам копировать файлы, подключать всё в `index.html` по-старинке, если мы можем в джс-файлах импортить **вообще всё что угодно**?\n\n![](https://i.imgur.com/3oQKttO.png)\n\nПро Вебпак ходит очень много слухов, что он сложный, но это не так: он сложный когда вам нужно заниматься тонкими оптимизациями.\n\nДавайте попробуем собрать демку в отдельном проекте без CRA? Напишем тот же Hello World на Реакте и соберём всё Вебпаком.\n\nКонечная структура у нас будет такая:\n\n```\nwebpack-demo\n├── .gitignore       # пропишем сами\n├── package.json     # создастся через yarn init\n├── webpack.config.js\n├── node_modules\n│   └── ...\n├── src              # создадим руками\n│   └── index.js     # наше Реакт-приложение\n├── build            # создаётся Вебпаком\n│   └── bundle.js\n└── public           # создадим руками\n    └── index.html\n```\n\nФайлы `src/index.js` и `public/index.html` мы создадим руками, а потом — вызовем `yarn init` чтобы создать `package.json`.\n\nИ не забудьте сделать Гитигнор, иначе туда улетит `build` и `node_modules`, а этого не стоит делать — в репозитории должны быть только исходники.\n\n#### `.gitignore`\n\n```\n# dependencies\n/node_modules\n\n# production\n/build\n\n# misc\n.DS_Store\n.vscode\nyarn-error.log\n```\n\n#### `public/index.html`\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>React App</title>\n</head>\n\n<body>\n  <div id=\"app\"></div>\n</body>\n\n</html>\n```\n\n#### `src/index.js`\n\n```js\nimport React from \"react\";\nimport { render } from \"react-dom\";\n\nfunction App() {\n  return <h1>Hello, world</h1>;\n}\n\nrender(<App />, document.getElementById(\"app\"));\n```\n\nПосле этого ставим через Ярн `webpack-cli` и `webpack-dev-server`: `yarn add --dev webpack-cli webpack-dev-server`.\n\nПервый будет билдить наш проект, второй — отслеживать изменения когда мы работаем локально.\n\n#### `webpack.config.js`\n\n```js\n// подключим модуль `path` из ноды,\n// чтобы построить абсолютный путь\n// до директории build\nconst path = require(\"path\");\n\nmodule.exports = {\n  entry: \"./src/index.js\",\n  output: {\n    filename: \"bundle.js\",\n    path: path.join(__dirname, \"build\")\n  }\n};\n```\n\nТеперь пробуем запустить как `yarn webpack` и увидим ошибку:\n\n```\nWARNING in configuration\nThe 'mode' option has not been set. Set 'mode' option to 'development' or 'production' to enable defaults for this environment.\n\nERROR in ./src/index.js\nModule parse failed: Unexpected token (6:4)\nYou may need an appropriate loader to handle this file type.\n| function App() {\n|   return (\n|     <h1>Hello, world</h1>\n|   )\n| }\n```\n\nНу, во-первых, поставим ещё `mode: \"development\"` в `webpack.config.js`, а, во-вторых, исправим ошибку.\n\n---\n\nПро настройку Вебпака ходит много смешков, потому что сам он ничего не умеет. Он как Бейбель: расширяется через плагины, только тут они называются **лоадерами**.\n\nНапример, если мы импортим ЦСС-файл, то нам нужны лоадеры [`style-loader`](https://github.com/webpack-contrib/style-loader) и [`css-loader`](https://github.com/webpack-contrib/css-loader) и Вебпак вставит ЦСС-код в `<style></style>` теги в начале страницы.\n\nЕсли мы импортим шрифты, картинки или ещё что, то нужен будет [`file-loader`](https://github.com/webpack-contrib/file-loader), который при импорте вернёт сгенерированный путь к файлу.\n\n```javascript\nimport logo from \"./logo.svg\";\n\nconsole.log(logo); // \"/static/images/0dcbbaa7013869e351f.png\"\n```\n\nНо как нам работать с ошибкой выше? Мы же написали нормальный код, джаваскриптовский!\n\nНам понадобится [`babel-loader`](https://github.com/babel/babel-loader) c пресетами `babel-preset-env` (для современного Джаваскрипта с `const`, `async-await` и прочим) и `babel-preset-react` (для Джсх).\n\n`yarn add --dev babel-loader babel-core babel-preset-env babel-preset-react`\n\nИ, конечно же, нужно [отредактировать конфиг](https://github.com/babel/babel-loader#usage) Вебпака, чтобы он знал, что на `.js` файлы нужно натравить именно `babel-loader`.\n\n```js\nconst path = require(\"path\");\n\nmodule.exports = {\n  mode: \"development\",\n  entry: \"./src/index.js\",\n  output: {\n    filename: \"bundle.js\",\n    path: path.join(__dirname, \"build\")\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/, // регулярное выражение\n        exclude: path.join(__dirname, \"node_modules\"),\n        use: {\n          loader: \"babel-loader\",\n          options: {\n            presets: [\"babel-preset-env\", \"babel-preset-react\"]\n          }\n        }\n      }\n    ]\n  }\n};\n```\n\n> Когда я писал этот урок, Бейбел был ещё 6.x версии. В [7.x](http://babeljs.io/blog/2017/12/27/nearing-the-7.0-release) пакеты вместо `babel-x` стали `@babel/x`. Для этого, кстати, используется [Scoped Packages](https://docs.npmjs.com/getting-started/scoped-packages) в Нпм/Ярн.\n\nПробуем запустить?\n\n```\nwebpack-demo $ yarn webpack\nyarn run v1.5.1\n$ /private/tmp/webpack-demo/node_modules/.bin/webpack\nHash: 708efebfede93aa32071\nVersion: webpack 4.1.1\nTime: 700ms\nBuilt at: 2018-3-20 10:48:12\n    Asset      Size  Chunks             Chunk Names\nbundle.js  3.54 KiB    main  [emitted]  main\nEntrypoint main = bundle.js\n[./src/index.js] 430 bytes {main} [built]\n\nERROR in ./src/index.js\nModule not found: Error: Can't resolve 'react' in '/private/tmp/webpack-demo/src'\n @ ./src/index.js 3:13-29\n\nERROR in ./src/index.js\nModule not found: Error: Can't resolve 'react-dom' in '/private/tmp/webpack-demo/src'\n @ ./src/index.js 7:16-36\n```\n\nАга, опять ошибки, но теперь понятные: нужно просто поставить `react` и `react-dom`. Установили, пробуем ещё раз:\n\n```\nwebpack-demo $ yarn webpack\nyarn run v1.5.1\n$ /private/tmp/webpack-demo/node_modules/.bin/webpack\nHash: c1cba3ec70e6f308e028\nVersion: webpack 4.1.1\nTime: 1341ms\nBuilt at: 2018-3-20 10:49:36\n    Asset     Size  Chunks                    Chunk Names\nbundle.js  634 KiB    main  [emitted]  [big]  main\nEntrypoint main [big] = bundle.js\n[./src/index.js] 430 bytes {main} [built]\n    + 23 hidden modules\n✨  Done in 2.35s.\n```\n\nГотово! Проверяем нашу директорию `build` и видим красивый файл `bundle.js`\n\n![](https://i.imgur.com/Kwz67Ft.png)\n\nЕго же мы и подключаем в `public/index.html` и потом открываем в браузере.\n\n![](https://i.imgur.com/Z12e4JE.png)\n\n### `webpack-dev-server`\n\nА что делать, если вы очень много разрабатываете и постоянно вызывать `yarn webpack` утомляет?\n\nДля этого есть `webpack-dev-server`: небольшой сервер, который крутится на `http://localhost:8080/` и раздаёт файлы оттуда.\n\n```\nwebpack-demo $ yarn webpack-dev-server\nyarn run v1.5.1\n$ /private/tmp/webpack-demo/node_modules/.bin/webpack-dev-server\nℹ ｢wds｣: Project is running at http://localhost:8080/\nℹ ｢wds｣: webpack output is served from /\nℹ ｢wdm｣: Hash: 58502b2391c6e006927e\nVersion: webpack 4.1.1\nTime: 1931ms\n```\n\nНас интересуют две строчки:\n\n```\nℹ ｢wds｣: Project is running at http://localhost:8080/\nℹ ｢wds｣: webpack output is served from /\n```\n\nПервая означает, что Вебпак раздаёт файлы по адресу `http://localhost:8080/`, а вторая — что файлы находятся в корне, этого адреса.\n\n![](https://i.imgur.com/XQocytG.png)\n\nПоэтому нам нужно заменить в `public/index.html` адрес до Джс-файла:\n\n```html\n<script  src=\"../build/bundle.js\"></script>\n\n<script  src=\"http://localhost:8080/bundle.js\"></script>\n```\n\n## CRA\n\nДля вас команда фейсбука и CRA сделали одну небольшую команду `react-script build` (она же прописана в `package.json > scripts > build` чтобы её можно было вызвать как `yarn build`). Об этом лучше [прочитать](https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#npm-run-build) в официальной документации CRA.\n\n## Итог\n\nКачество кода многое говорит о разработчике. Можно руками соблюдать какой-нибудь стайлгайд, а можно воспользоваться Еслинтом, настроить его и радоваться жизни.\n\nПлюс мы узнали как работает Бейбель — парсер и компилятор Джаваскрипта в… Джаваскрипт; плюс разобрались как развивается ECMAScript.\n\nИ третьим пунктом мы прошлись по Вебпаку — мощному, но несложному для новичков бандлеру модулей.\n\n## Задание на Еслинт\n\nВ вашем проекте воткните самый жёсткий конфиг Еслинта: [airbnb-config-eslint](https://npm.im/eslint-config-airbnb). Не забудьте проверить проект на ошибки, вызвав Еслинт.\n\nУчтите, что установка этого конфига не самая тривиальная, поэтому читайте внимательно документацию: там недостаточно написать `yarn add --dev eslint-config-airbnb`.\n\n## Задания на Вебпак\n\nДемо с Вебпаком я выложил на [Гитхаб](https://github.com/evgenyrodionov/webpack-demo), для вас есть задания:\n\n- нужен работающий `import './styles.css'`,\n- нужен работающий `import logo from './logo.png'`, где `logo` будет ссылкой на файл,\n- нужно настроить Вебпак так, чтобы можно было делать `import Button from 'ui/Button` вместо `import Button from '../../../../../../../../../ui/Button`.\n\nДля первых двух задания вам нужны лоадеры, для третьего — настройка конфига Вебпака.\n\n<p class=\"announce\">\n  Не забывайте задавать вопросы в чате — там обязательно помогут 💪🏻 <br><br> Помните: нет глупых вопросов, есть лишь страх их задавать.\n</p>\n","id":"Iks8U64Jln","stageId":"tHKYMIR4QG"}