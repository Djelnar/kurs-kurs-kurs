{"stage":1,"title":"Что такое Реакт?","subTitle":"Реакт выбирают уже пять лет, почему это вряд ли когда-то закончится?","markdown":"## История фронтэнда\n\n_Если вы не читали [Историю интернета](https://erodionov.ru/courses/verstka/FhTKluFzm7/nHdviS9Jil) — сейчас самое время._\n\nВ [курсе по вёрстке](https://erodionov.ru/courses/verstka) мы разбирали самую обычную вёрстку через ХТМЛ и ЦСС. Да, стандарты развиваются, W3C и WHATWG делают правильные вещи, но на вёрстке интерфейсы не построишь.\n\n### jQuery — 2006, Google Chrome — 2008\n\nПримерно в 2006 году [появилась](https://en.wikipedia.org/wiki/JQuery) библиотека Джквери — мощная штука, цель которой была унифицировать поведение браузеров. На тот момент было не так много браузеров и у всех них была разная реализация одного и того же! Джквери это исправлял: прятал реализацию за небольшими функциями. Эти функции — АПИ библиотеки, про АПИ мы ещё поговорим.\n\nЗатем в 2008 году Гугл вышел на рынок браузеров со своим Хромом и движком V8: это был прорыв, браузеры, оказывается, могут быстро работать! После ИЕ6 и всяких Опер это был глоток воздуха, поэтому Хром очень быстро стал браузером №1. That shit cray!\n\n### Backbone.js и Knockout — 2010\n\nПрошло два года, браузеры развиваются (Майкрософт сподобился выпустить ИЕ8 в 2009, но он давно уже был не жилец), железо улучшается, а DX (Developer Experience) не особо.\n\nПосудите сами: у нас появилась возможность делать какие-то приложения, началось обсуждение [Флекбоксов](https://en.wikipedia.org/wiki/CSS_flex-box_layout), через год появится [Бутстрап](<https://en.wikipedia.org/wiki/Bootstrap_(front-end_framework)>), а мы до сих пор через Джквери пишем огромную лапшу кода чтобы работать с интерфейсом. Не очень удобно.\n\nВ те времена был популярен Ruby On Rails с подходом Model-View-Controller (он считался самым удобным), поэтому какой логичный результат? Давайте заберём его на фронтэнд и сделаем Backbone.js! Заодно и Knockout, но уже на MVVM (Model-View-ViewModel).\n\nMVC это способ работы с данными: есть **модель** данных, есть **контроллер**, который ею управляет, есть **вью**, который их отображает.\n\nMVVM ещё хуже, вот что вам про него нужно знать! Но если серьёзно, то это лежит в области two-way data binding: работа с данными в обе стороны (через вью обновляется модель, через модель обновляется вью).\n\n### AngularJS — 2010 и EmberJS — 2011\n\nВ том же 2010 вышел Ангулар — фреймворк от Гугла, в котором и был реализован MVVM. Отличие фреймворков от библиотек в том, что они диктуют вам правила и предоставляют много готовых решений: представьте как удобно получить несколько библиотек от одного поставщика!\n\nСпойлер: неудобно. Потому что эти решения рассчитаны на типовые решения, если ваше в него не укладывается — здравствуйте, костыли и велосипеды.\n\nАнгулар был неплохим: после Джквери (Нокаут и Бэкбон не особо завоевали популярность) это был глоток свежего воздуха. Проблем у Ангулара было несколько:\n\n* это всё ещё MVC/MVVM,\n* стандарты не были готовы к two-way data binding и в итоге он был очень прожорлив по ресурсам,\n* разработчики Ангулара тоже не особо умели это исправить,\n* Ангулар2 должен был быть совершенно другим — потеря обратной совместимости.\n\nТем не менее, с Ангуларом мы прожили несколько лет пока в марте 2013 года не появился Реакт. Примерно в те же времена был анонс Ангулара 2 без обратной совместимости, поэтому Реакт был весьма кстати!\n\n### Реакт — 2013\n\nРеакт был удивительным: он принёс с собой компонентный подход, локальный стейт и декларативный подход, где интерфейс рендерится (показывается) от данных. Уравнением это выглядит как `ui = render(state)`, чуть позже вы это поймёте.\n\nИтак, представьте: у вас есть данные, например, вы работаете с недвижимостью и у вас есть список объектов, который нужно отрисовать. В MVC вам бы пришлось размазывать это на три слоя (и вообще помнить что они существуют! представьте как это неудобно), а тут всё в одном компоненте.\n\nЯ вам покажу псевдокод, думаю, вы его поймёте:\n\n```jsx\nclass PropertiesList extends React.Component {\n  state = {\n    properties: [\n      {\n        id: 101,\n        title: \"2-комнатная квартира в Хамовниках\",\n        images: [\n          {\n            id: \"PRO-101-6c0mq7u3Qo\",\n            isPublic: true\n          },\n          {\n            id: \"PRO-101-7EScTXC6zT\",\n            isPublic: false\n          }\n        ]\n      },\n      {\n        id: 201,\n        title: \"5-комнатный пентхаус в Тверском\",\n        images: [\n          {\n            id: \"PRO-201-oazwaN0JTS\",\n            isPublic: true\n          },\n          {\n            id: \"PRO-201-zptmLoC38q\",\n            isPublic: false\n          }\n        ]\n      }\n    ]\n  };\n\n  render() {\n    return (\n      <section>\n        <h2>Список квартир</h2>\n        {this.state.properties.map(property => (\n          <a href={`/properties/${property.id}`} key={property.id}>\n            <img src={`https://images.com/${property.images[0].id}`} />\n            <h3>{property.title}</h3>\n          </a>\n        ))}\n      </section>\n    );\n  }\n}\n```\n\nНе то чтобы сложный, но не то чтобы очень понятный. Это ок — это же курс, всё предстоит впереди :)\n\nТем не менее, уже видно что стейт и рендер находятся в одном классе. В одном компоненте.\n\n---\n\nКстати, одно из важных отличий Реакта от всего остального типа Ангулара или Эмбера: он работает с Джаваскриптом, а не с придуманным шаблонизации.\n\nЕсли вы [посмотрите на Вью](https://vuejs.org/v2/guide/), то мало того что там MVVM, так ещё и свой птичий язык:\n\n```html\n<div id=\"app-2\">\n  <span v-bind:title=\"message\">\n    Hover your mouse over me for a few seconds\n    to see my dynamically bound title!\n  </span>\n</div>\n\n<div id=\"app-3\">\n  <span v-if=\"seen\">Now you see me</span>\n</div>\n\n<div id=\"app-4\">\n  <ol>\n    <li v-for=\"todo in todos\">\n      {{ todo.text }}\n    </li>\n  </ol>\n</div>\n```\n\nВсе эти `v-bind`, `v-if`, `v-for` — это не из нативного ХТМЛа или Джаваскрипта. У Реакта всё построено на чистом Джаваскрипте и в этом его гигантский плюс.\n\n## Плюсы Реакта и его перспективы\n\n* **Декларативен**, а потому предсказуем: каждый раз вы будете получать один и тот же результат,\n* **Быстр**: он использует virtual dom и обновляет только измененный кусок,\n* **Жив**: коммьюнити Реакта — самое гигантское и оно не думает его забрасывать,\n* **Используется Фейсбуком**: eat your own dog food, как говорится,\n* **Чертовски популярен**: Реакт на первом месте в выборе работодателей и разработчиков. Пример: [The State Of JavaScript 2017](https://stateofjs.com/).\n* **Подходит для всех проектов**: от маленьких за день типа [alisa2018.ru](https://alisa2018.ru/), [vot-vot.net](https://vot-vot.net/) и [23na8.ru](http://23na8.ru/) до крупных внутренних систем как [Додо ИС](http://dodois.com/).\n\nЭто не сейл-спич. Реакт действительно поменял фронтэнд и он идеален настолько, насколько это возможно. Реакт стал стандартом во фронтэнде.\n\n### Принципы Реакта\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/f11f8ksArp4\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe>\n\n_Монтаж дерьмовый: звук с камеры (а не с микрофона), торчит \"2 неделя\", в будущем исправим_\n\n---\n\nКстати, часто спрашивают что плохого во Вью или Ангуларе (или хорошего, выбирают же их зачем-то). Курс по Реакту, но всё равно расскажу.\n\nАнгулар или Вью не плохие, это просто технологии. Я уже [писал обзор](https://t.me/rodionovrodionovrodionov/416) про все три столпа фронтэнда и хочу дополнить стереотипами.\n\n* **Ангулар для энтерпрайза и сложных приложений**: возможно, потому что он форсирует использование Тайпскрипта и грузит разработчикам мозг [кучей сложных (и бессмысленных) вещей](https://angular.io/guide/architecture) типа Dependency Injection, директив, сервисов и прочего. Лично я слишком глупый для этого, поэтому стараюсь не выбирать вещи, которые мешают мне добиваться решения задач и заставляют погружаться во внутреннюю реализацию. Зато в Ангуларе идёт в комплекте свой роутер и http-клиент.\n\n* **Вью для простых проектов**. Да: потому что его действительно можно подключить по-старинке через тег `<script>`.\n\nНо вот в чём нюанс: эти положения не означают, что их нужно выбирать в приоритет перед Реактом. Реакт всё также подходит для маленьких проектов (благодаря [create-react-app](https://github.com/facebook/create-react-app)), его также [можно воткнуть](https://medium.com/родионов-и-разработка/d154dbae5f51) в уже существующий сайт, и он всё также подходит для больших проектов, потому что у него огромное сообщество и огромное количество готовых библиотек — в том числе тех, которые несколько раз ломали обратную совместимость потому что пытались найти так называемый react-way.\n\n## Итог\n\nСегодня мы очень коротко коснулись Реакта: узнали что он компонентный и предлагает использовать чистый Джаваскрипт в отличие от Вью, Ангулара или каких-либо ещё фреймворков и библиотек.\n\nЗато мы узнали про историю фронтэнда!\n","id":"OK9uhah8uI","stageId":"9wO7ihaBIk"}