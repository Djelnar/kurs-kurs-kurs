{
  "stageName": "Этап третий: фронтэнд на стероидах",
  "lessons": [
    {
      "stage": 3,
      "title": "Про Вебпак, Бейбель, Еслинт без create-react-app",
      "subTitle": "Разбираемся в тех технологиях, о которых ходят слухи, что они сложные",
      "markdown": "Сегодня мы разберёмся с тем, как устроен create-react-app под собой.\n\n## Еслинт\n\nОкей, мы поставили преттир и настроили Еслинт на работу с дефолтным конфигом CRA ([`eslint-config-react-app`](https://www.npmjs.com/package/eslint-config-react-app)).\n\n[Еслинт](https://eslint.org/) это утилита, которая анализирует ваш код по заданным правилам.\n\nРаботает он сам по себе легко: вы ставите `eslint` как зависимость и в [файле конфига](https://eslint.org/docs/user-guide/configuring) задаёте настройки, по которым он работает.\n\nНастроек много, но нас интересуют три: правила (`rules`), плагины (`plugins`) и расширение через готовый конфиг (`extends`).\n\n### Правила\n\nОснова Еслинта это правила: вы указываете готовое правило ([список из дефолтных](https://eslint.org/docs/rules/)) и как Еслинту нужно себя вести.\n\n#### Показываем неиспользуемые значения\n\nПример: вы пишите код и хотите знать когда у вас остался мусор — вы объявили какую-нибудь константу или функцию, но не используете её. За это отвечает правило [no-unused-vars](https://eslint.org/docs/rules/no-unused-vars) (уточню, что `vars` тут в контексте слова `variables`, а не `var` из Джса).\n\nВы создаёте [`.eslintrc.json`](https://eslint.org/docs/user-guide/configuring#configuration-file-formats) и там прописываете это правило:\n\n```json\n{\n  \"rules\": {\n    \"no-unused-vars\": \"error\"\n  }\n}\n```\n\n`\"error\"` означает что это грубая ошибка. Бывает ещё `\"off\"` и `\"warn\"`.\n\n#### Запретим использовать `var`\n\nВ ES6 (он же ES2015) — версия стандарта ECMAScript, по которому работает Джс — добавили `let` и `const`.\n\nКак вы помните из второго урока, отличие в том, что `const` это неизменяемое значение, а у `let` область видимости ограничена блоком, где она объявлена (но при этом переопределять можно).\n\nМы не хотим использовать `var`, поэтому нам поможет правило [`no-var`](https://eslint.org/docs/rules/no-var).\n\nВ `.eslintrc.json` дописываем\n\n```diff\n{\n  \"rules\": {\n    \"no-unused-vars\": \"error\",\n+   \"no-var\": \"error\"\n  }\n}\n```\n\n### Плагины\n\nНо как запретить использовать и `let` тоже? Для этого есть плагин [`eslint-plugin-fp`](https://github.com/jfmengels/eslint-plugin-fp), он форсит функциональное программирование, в том числе и иммутабельность.\n\nПлагины подключаются легко: ставите как зависимость, потом в `.eslintrc.json` прописываете поле `plugins` с массивом используемых плагинов, а в `rules` — правило, где префиксом будет название плагина. Щас покажу!\n\n```diff\n{\n+ \"plugins\": [\"fp\"],\n  \"rules\": {\n    \"no-unused-vars\": \"error\",\n    \"no-var\": \"error\",\n+   \"fp/no-let\": \"error\"\n  }\n}\n```\n\n_(кстати, в перечислении плагинов можно опустить префикс `eslint-plugin-` и оставить только `fp`)_\n\nЕсть [очень много плагинов](https://www.npmjs.com/browse/keyword/eslintplugin), например, [`eslint-plugin-react`](https://www.npmjs.com/package/eslint-plugin-react) который отвечает за работу с Реактом или [`eslint-plugin-import`](https://www.npmjs.com/package/eslint-plugin-import) который смотрит за импортами.\n\n### Готовые конфиги\n\nНо Женя, неужели это всё руками прописывать надо? Огромные же конфиги получаются, плюс Еслинт и плагины обновляются, правила добавляются, мне что, за этим следить постоянно?\n\nСлава богу нет! У многих плагинов есть рекомендуемая конфигурация, как и у Еслинта. Использование поля `extends` описано в [документации](https://eslint.org/docs/user-guide/configuring#extending-configuration-files).\n\nЭкстендить можно только несколько конфигов, например, можно взять `eslint:recommended`, `plugin:fp/recommended` и `plugin:react/recommended`:\n\n```diff\n{\n  \"plugins\": [\"fp\", \"react\"],\n+ \"extends\": [\n+   \"eslint:recommended\",\n+   \"plugin:fp/recommended\",\n+   \"plugin:react/recommended\"\n+ ],\n  \"rules\": {\n    \"no-unused-vars\": \"error\",\n    \"no-var\": \"error\",\n    \"fp/no-let\": \"error\"\n  }\n}\n```\n\nПри этом правила, которые объявлены в `rules`, будут перебивать те, что указаны в самих конфигах.\n\n#### Конфиг от Эйрбнб\n\nЭйрбнб очень много вкладываются в опенсорс и много лет назад [написали популярный стайлгайд по Джаваскрипту](http://github.com/airbnb/javascript) — советую его прочитать.\n\nЧто такое стайлгайд? Это правила. С чем работает еслинт? С правилами. В итоге ребята сделали свой конфиг по этому стайлгайду: [`eslint-config-airbnb`](https://www.npmjs.com/package/eslint-config-airbnb).\n\nОн самый жёсткий из всех: ваш код будет на 99% красным, но зато он будет самым красивым и правильным из всех, что когда-либо показывали на откликах и собеседованиях ❤️\n\nЖизнь без Преттира и Еслинта:\n![](https://i.imgur.com/7nJRNtl.png?1)\n\n### Поле `parser` и Бейбель\n\nКогда вы поставите конфиг от Эйрбнб, Еслинт может сломаться и начать выдавать `unexpected token =` и другие ошибки. За это отвечает парсер — Еслинт не может спарсить (проанализировать) ваш код.\n\nПо-умолчанию Еслинт использует [Espree](https://github.com/eslint/espree), но он не обновлялся долгое время и поэтому не поддерживает ES6 и другие нововведения Джаваскрипта (помните про [`babel-plugin-transform-class-properties`](https://babeljs.io/docs/plugins/transform-class-properties/)?). Но, к счастью, парсер в Еслинте можно сменить через поле `parser`, вам понадобится [`babel-eslint`](https://github.com/babel/babel-eslint).\n\nКак вы понимаете, использовать легко: ставите как зависимость, указываете в поле `parser`\n\n```diff\n{\n+ \"parser\": \"eslint\",\n  \"plugins\": [\"fp\", \"react\"],\n  \"extends\": [\n    \"eslint:recommended\",\n    \"plugin:fp/recommended\",\n    \"plugin:react/recommended\"\n  ],\n  \"rules\": {\n    \"no-unused-vars\": \"error\",\n    \"no-var\": \"error\",\n    \"fp/no-let\": \"error\"\n  }\n}\n```\n\n## Бейбель\n\nКстати, о Бейбеле мы ещё не говорили.\n\n[Бейбель](http://babeljs.io/) это компилятор Джаваскрипта в Джаваскрипт.\n\nЕсли вы проходили [курс по вёрстке](https://erodionov.ru/verstka), то там есть урок про ПостЦСС и [cssnext](http://cssnext.io/) — способ писать будущий ЦСС уже сегодня. Достигается это за счёт того, что новый код превращается в старый с помощью ПостЦСС.\n\nБэйбель работает так же: вы пишите современный код (но который не поддерживают браузеры), прогоняете его Бейбелем и получаете тот, что поддерживается браузером.\n\n_Хотите узнать как работают компиляторы? Почитайте [The Super Tine Compiler](https://github.com/thejameskyle/the-super-tiny-compiler)._\n\nПомните, в третьем уроке мы говорили про JSX и что это всего лишь синтаксический сахар и на самом деле Реакт построен на методах `React.createElement()`? Именно этим и занимается Бейбель и плагин [`babel-plugin-transform-react-jsx`](https://babeljs.io/docs/plugins/transform-react-jsx/): превращает удобный для вас JSX в понятный браузеру `React.createElement()`. [Попробуйте в REPL](http://babeljs.io/repl).\n\n```jsx\n// input\nimport React from \"react\";\n\nconst HelloWorld = () => <div>Hello, world</div>;\n\n<HelloWorld />;\n\n// output\n(\"use strict\");\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : { default: obj };\n}\n\nvar HelloWorld = function HelloWorld() {\n  return _react2.default.createElement(\"div\", null, \"Hello, world\");\n};\n\n_react2.default.createElement(HelloWorld, null);\n```\n\nУ Бейбеля есть [много плагинов](http://babeljs.io/docs/plugins/), но, как и Еслинт, есть готовые пакеты — они называются пресетами (`preset`).\n\nРаньше были популярны `stage-*`-пресеты, но потом от них решили отказаться в пользу [`babel-preset-env`](http://babeljs.io/docs/plugins/preset-env/).\n\nЧто за стейджи? Стандарт Джаваскрипта (ECMAScript) развивается, им занимается комитет TC39. Работает он так: кто-то описывает новую функциональность в Джаваскрипте, кидает пропозал (proposal), комитет обсуждает на одной из встречи и двигает по стейджам: от 0 (самый сырой черновик) до 4 (вошло в стандарт). Список всех текущих пропозалов можно увидеть в репозитории [tc39/proposals](https://github.com/tc39/proposals).\n\nНапример, в стандарте [уже](https://github.com/tc39/proposals/blob/master/finished-proposals.md) есть [`Array.prototype.includes`](https://github.com/tc39/Array.prototype.includes), [async функции](https://github.com/tc39/ecmascript-asyncawait), [методы `Object.entries()` и `Object.values()`](https://github.com/tc39/proposal-object-values-entries) и другие.\n\nРаз они есть в стандарте — браузеры должны реализовать, но мы же не можем так долго ждать, нам нужно писать код с этими фичами уже сегодня! Для этого и существуют плагины Бейбеля, например, [`babel-plugin-array-includes`](https://www.npmjs.com/package/babel-plugin-array-includes).\n\nНа самом деле, этот блок про Бейбель чисто теоретический: в CRA он настолько хорошо настроен, что вам вряд ли придётся с ним столкнуться.\n\nCRA использует собственный пресет [`babel-preset-react-app`](https://github.com/facebook/create-react-app/tree/master/packages/babel-preset-react-app), куда уже включены плагины [`babel-plugin-transform-object-rest-spread`](http://babeljs.io/docs/plugins/transform-object-rest-spread/) и [`babel-plugin-transform-react-jsx`](http://babeljs.io/docs/plugins/transform-react-jsx/), но если бы вы хотели написать свой конфиг, то ваш `.babelrc` выглядел бы так:\n\n```json\n{\n  \"plugins\": [\"transform-object-rest-spread\", \"transform-react-jsx\"]\n}\n```\n\n_(как и у Еслинта, префикс `babel-plugin-` можно опустить)_\n\nКак видите, ничего сложного. Но что делать потом? Вам нужно скомпилировать ваш исходник в джс, который понятен браузеру.\n\nПоставьте `babel-cli` и запустите его как `yarn run babel [src] -d [dest]`, где `src` это директория с исходниками, а `dest` это куда нужно скопировать результат. Пример: `yarn run babel src -d build`.\n\nВсем этим (и другим) занимается Вебпак.\n\n## Вебпак\n\n[Вебпак](http://webpack.js.org/) — это бандлер модулей. В какой-то момент создатель Вебпака подумал: а зачем нам копировать файлы, подключать всё в `index.html` по-старинке, если мы можем в джс-файлах импортить **вообще всё что угодно**?\n\n![](https://i.imgur.com/3oQKttO.png)\n\nПро Вебпак ходит очень много слухов, что он сложный, но это не так: он сложный когда вам нужно заниматься тонкими оптимизациями.\n\nДавайте попробуем собрать демку в отдельном проекте без CRA? Напишем тот же Hello World на Реакте и соберём всё Вебпаком.\n\nКонечная структура у нас будет такая:\n\n```\nwebpack-demo\n├── .gitignore       # пропишем сами\n├── package.json     # создастся через yarn init\n├── webpack.config.js\n├── node_modules\n│   └── ...\n├── src              # создадим руками\n│   └── index.js     # наше Реакт-приложение\n├── build            # создаётся Вебпаком\n│   └── bundle.js\n└── public           # создадим руками\n    └── index.html\n```\n\nФайлы `src/index.js` и `public/index.html` мы создадим руками, а потом — вызовем `yarn init` чтобы создать `package.json`.\n\nИ не забудьте сделать Гитигнор, иначе туда улетит `build` и `node_modules`, а этого не стоит делать — в репозитории должны быть только исходники.\n\n#### `.gitignore`\n\n```\n# dependencies\n/node_modules\n\n# production\n/build\n\n# misc\n.DS_Store\n.vscode\nyarn-error.log\n```\n\n#### `public/index.html`\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>React App</title>\n</head>\n\n<body>\n  <div id=\"app\"></div>\n</body>\n\n</html>\n```\n\n#### `src/index.js`\n\n```js\nimport React from \"react\";\nimport { render } from \"react-dom\";\n\nfunction App() {\n  return <h1>Hello, world</h1>;\n}\n\nrender(<App />, document.getElementById(\"app\"));\n```\n\nПосле этого ставим через Ярн `webpack-cli` и `webpack-dev-server`: `yarn add --dev webpack-cli webpack-dev-server`.\n\nПервый будет билдить наш проект, второй — отслеживать изменения когда мы работаем локально.\n\n#### `webpack.config.js`\n\n```js\n// подключим модуль `path` из ноды,\n// чтобы построить абсолютный путь\n// до директории build\nconst path = require(\"path\");\n\nmodule.exports = {\n  entry: \"./src/index.js\",\n  output: {\n    filename: \"bundle.js\",\n    path: path.join(__dirname, \"build\")\n  }\n};\n```\n\nТеперь пробуем запустить как `yarn webpack` и увидим ошибку:\n\n```\nWARNING in configuration\nThe 'mode' option has not been set. Set 'mode' option to 'development' or 'production' to enable defaults for this environment.\n\nERROR in ./src/index.js\nModule parse failed: Unexpected token (6:4)\nYou may need an appropriate loader to handle this file type.\n| function App() {\n|   return (\n|     <h1>Hello, world</h1>\n|   )\n| }\n```\n\nНу, во-первых, поставим ещё `mode: \"development\"` в `webpack.config.js`, а, во-вторых, исправим ошибку.\n\n---\n\nПро настройку Вебпака ходит много смешков, потому что сам он ничего не умеет. Он как Бейбель: расширяется через плагины, только тут они называются **лоадерами**.\n\nНапример, если мы импортим ЦСС-файл, то нам нужны лоадеры [`style-loader`](https://github.com/webpack-contrib/style-loader) и [`css-loader`](https://github.com/webpack-contrib/css-loader) и Вебпак вставит ЦСС-код в `<style></style>` теги в начале страницы.\n\nЕсли мы импортим шрифты, картинки или ещё что, то нужен будет [`file-loader`](https://github.com/webpack-contrib/file-loader), который при импорте вернёт сгенерированный путь к файлу.\n\n```javascript\nimport logo from \"./logo.svg\";\n\nconsole.log(logo); // \"/static/images/0dcbbaa7013869e351f.png\"\n```\n\nНо как нам работать с ошибкой выше? Мы же написали нормальный код, джаваскриптовский!\n\nНам понадобится [`babel-loader`](https://github.com/babel/babel-loader) c пресетами `babel-preset-env` (для современного Джаваскрипта с `const`, `async-await` и прочим) и `babel-preset-react` (для Джсх).\n\n`yarn add --dev babel-loader babel-core babel-preset-env babel-preset-react`\n\nИ, конечно же, нужно [отредактировать конфиг](https://github.com/babel/babel-loader#usage) Вебпака, чтобы он знал, что на `.js` файлы нужно натравить именно `babel-loader`.\n\n```js\nconst path = require(\"path\");\n\nmodule.exports = {\n  mode: \"development\",\n  entry: \"./src/index.js\",\n  output: {\n    filename: \"bundle.js\",\n    path: path.join(__dirname, \"build\")\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/, // регулярное выражение\n        exclude: path.join(__dirname, \"node_modules\"),\n        use: {\n          loader: \"babel-loader\",\n          options: {\n            presets: [\"babel-preset-env\", \"babel-preset-react\"]\n          }\n        }\n      }\n    ]\n  }\n};\n```\n\n> Когда я писал этот урок, Бейбел был ещё 6.x версии. В [7.x](http://babeljs.io/blog/2017/12/27/nearing-the-7.0-release) пакеты вместо `babel-x` стали `@babel/x`. Для этого, кстати, используется [Scoped Packages](https://docs.npmjs.com/getting-started/scoped-packages) в Нпм/Ярн.\n\nПробуем запустить?\n\n```\nwebpack-demo $ yarn webpack\nyarn run v1.5.1\n$ /private/tmp/webpack-demo/node_modules/.bin/webpack\nHash: 708efebfede93aa32071\nVersion: webpack 4.1.1\nTime: 700ms\nBuilt at: 2018-3-20 10:48:12\n    Asset      Size  Chunks             Chunk Names\nbundle.js  3.54 KiB    main  [emitted]  main\nEntrypoint main = bundle.js\n[./src/index.js] 430 bytes {main} [built]\n\nERROR in ./src/index.js\nModule not found: Error: Can't resolve 'react' in '/private/tmp/webpack-demo/src'\n @ ./src/index.js 3:13-29\n\nERROR in ./src/index.js\nModule not found: Error: Can't resolve 'react-dom' in '/private/tmp/webpack-demo/src'\n @ ./src/index.js 7:16-36\n```\n\nАга, опять ошибки, но теперь понятные: нужно просто поставить `react` и `react-dom`. Установили, пробуем ещё раз:\n\n```\nwebpack-demo $ yarn webpack\nyarn run v1.5.1\n$ /private/tmp/webpack-demo/node_modules/.bin/webpack\nHash: c1cba3ec70e6f308e028\nVersion: webpack 4.1.1\nTime: 1341ms\nBuilt at: 2018-3-20 10:49:36\n    Asset     Size  Chunks                    Chunk Names\nbundle.js  634 KiB    main  [emitted]  [big]  main\nEntrypoint main [big] = bundle.js\n[./src/index.js] 430 bytes {main} [built]\n    + 23 hidden modules\n✨  Done in 2.35s.\n```\n\nГотово! Проверяем нашу директорию `build` и видим красивый файл `bundle.js`\n\n![](https://i.imgur.com/Kwz67Ft.png)\n\nЕго же мы и подключаем в `public/index.html` и потом открываем в браузере.\n\n![](https://i.imgur.com/Z12e4JE.png)\n\n### `webpack-dev-server`\n\nА что делать, если вы очень много разрабатываете и постоянно вызывать `yarn webpack` утомляет?\n\nДля этого есть `webpack-dev-server`: небольшой сервер, который крутится на `http://localhost:8080/` и раздаёт файлы оттуда.\n\n```\nwebpack-demo $ yarn webpack-dev-server\nyarn run v1.5.1\n$ /private/tmp/webpack-demo/node_modules/.bin/webpack-dev-server\nℹ ｢wds｣: Project is running at http://localhost:8080/\nℹ ｢wds｣: webpack output is served from /\nℹ ｢wdm｣: Hash: 58502b2391c6e006927e\nVersion: webpack 4.1.1\nTime: 1931ms\n```\n\nНас интересуют две строчки:\n\n```\nℹ ｢wds｣: Project is running at http://localhost:8080/\nℹ ｢wds｣: webpack output is served from /\n```\n\nПервая означает, что Вебпак раздаёт файлы по адресу `http://localhost:8080/`, а вторая — что файлы находятся в корне, этого адреса.\n\n![](https://i.imgur.com/XQocytG.png)\n\nПоэтому нам нужно заменить в `public/index.html` адрес до Джс-файла:\n\n```html\n<script  src=\"../build/bundle.js\"></script>\n\n<script  src=\"http://localhost:8080/bundle.js\"></script>\n```\n\n## CRA\n\nДля вас команда фейсбука и CRA сделали одну небольшую команду `react-script build` (она же прописана в `package.json > scripts > build` чтобы её можно было вызвать как `yarn build`). Об этом лучше [прочитать](https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#npm-run-build) в официальной документации CRA.\n\n## Итог\n\nКачество кода многое говорит о разработчике. Можно руками соблюдать какой-нибудь стайлгайд, а можно воспользоваться Еслинтом, настроить его и радоваться жизни.\n\nПлюс мы узнали как работает Бейбель — парсер и компилятор Джаваскрипта в… Джаваскрипт; плюс разобрались как развивается ECMAScript.\n\nИ третьим пунктом мы прошлись по Вебпаку — мощному, но несложному для новичков бандлеру модулей.\n\n## Задание на Еслинт\n\nВ вашем проекте воткните самый жёсткий конфиг Еслинта: [airbnb-config-eslint](https://npm.im/eslint-config-airbnb). Не забудьте проверить проект на ошибки, вызвав Еслинт.\n\nУчтите, что установка этого конфига не самая тривиальная, поэтому читайте внимательно документацию: там недостаточно написать `yarn add --dev eslint-config-airbnb`.\n\n## Задания на Вебпак\n\nДемо с Вебпаком я выложил на [Гитхаб](https://github.com/evgenyrodionov/webpack-demo), для вас есть задания:\n\n- нужен работающий `import './styles.css'`,\n- нужен работающий `import logo from './logo.png'`, где `logo` будет ссылкой на файл,\n- нужно настроить Вебпак так, чтобы можно было делать `import Button from 'ui/Button` вместо `import Button from '../../../../../../../../../ui/Button`.\n\nДля первых двух задания вам нужны лоадеры, для третьего — настройка конфига Вебпака.\n\n<p class=\"announce\">\n  Не забывайте задавать вопросы в чате — там обязательно помогут 💪🏻 <br><br> Помните: нет глупых вопросов, есть лишь страх их задавать.\n</p>\n",
      "isPublic": true,
      "id": "Iks8U64Jln",
      "stageId": "tHKYMIR4QG"
    },
    {
      "stage": 3,
      "title": "Билды и деплои",
      "subTitle": "Разрабатывать локально это прикольно, но интерфейсом должны пользоваться другие люди, верно?",
      "markdown": "Раньше всё было легко — воткнул джс в тег `<script>`, залил через ФТП и получил новый сайт. Сейчас всё стало сложнее:\n\n- во-первых, мы используем Бейбель, чтобы компилировать код из нового стандарта в тот, что поддерживается браузерами сейчас;\n- во-вторых, нужно минифицировать код;\n- в-третьих, Вебпак должен разбираться со всеми импортами: мы же не положим картинку в джс-файл, хоть мы её и импортим там?\n\nДля этого существует шаг **билда**.\n\n## Билд\n\nБилд (build) это этап сборки проекта: когда весь проект собирается в продакшен версию.\n\nПродакшен это один из видов окружения: места, где работает ваш код. Во фронтэнде продакшен-версия обычно означает, что файлы будут минифицированы, сжаты через какой-нибудь gzip, вырезаны лишние проверки, благодаря этому уменьшен код и так далее. Почитайте в [доке КРА](https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#deployment) — там об этом хорошо рассказано.\n\nБилдится проект через `react-scripts build` (эта команда уже записана в `package.json` под `build` благодаря CRA и поэтому можно вызвать как `yarn build`), после билда у вас будет директория `build` с файлами: `index.html` в корне, в `static` — `main.[hash].js`, `main.[hash].css` и так далее.\n\nЕсли вы откроете файл `build/index.html` в браузере, то вы получите белый экран и ошибку в консоли, что файлы .css и .js не найдены. Почему так?\n\n### `PUBLIC_URL`\n\nЕсли вы почитаете [документацию КРА](https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-assets-outside-of-the-module-system), то заметите некий параметр `PUBLIC_URL` — при билде КРА заменяет его на указанное значение.\n\nНапример, если ваш `PUBLIC_URL` равен `https://erodionov.ru`, то после билда ссылки на джс- и цсс-файлы будут выглядеть как\n\n```html\n<link href=\"https://erodionov.ru/static/css/main.e34a431d.css\" rel=\"stylesheet\">\n...\n<script src=\"https://erodionov.ru/static/js/main.6e03bcce.js\"></script>\n```\n\nКак указать паблик урл? Это делается [энв-параметром](https://www.digitalocean.com/community/tutorials/how-to-read-and-set-environmental-and-shell-variables-on-a-linux-vps): специальным параметром, который задаётся в системе.\n\nЕсли вы хотите вшить его до перезагрузки, то в Терминале вбейте `export PUBLIC_URL=...` — КРА подхватит при билде.\n\nЕсли вы не хотите вшивать в систему навсегда, а хотите лишь при вызове одной команды — укажите её перед вызовом, например, `PUBLIC_URL=... yarn build`. Это удобно, если вы работаете с несколькими проектами.\n\nЕсли вы работаете с несколькими проектами, то можете задуматься о файле `.env` — КРА [поддерживает](https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-custom-environment-variables) библиотеку [dotenv](http://npm.im/dotenv), которая устанавливает энв-параметры через файл `.env`, находящийся в корне проекта.\n\nИ вы, конечно же, можете установить свои энв-параметры: в Джсе благодаря Вебпаку они доступны в объекте `process.env` (например, `console.log(process.env.PUBLIC_URL)`), но хочу уточнить, что КРА [заставляет](https://github.com/facebook/create-react-app/issues/865#issuecomment-252199527) все кастомные энв-параметры префиксовать как REACT*APP*\\*. Ради безопасности!\n\n---\n\nОкей, с паблик урл и энв-параметрами разобрались, с билдом тоже — в `build` мы получаем готовую **статику**, а что делать с этим дальше? Люди же не будут заходить к вам на ноутбук и искать директорию билд.\n\n## Деплой\n\n[Деплой](https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#deployment) (deploy) это процесс **выкатки обновлений**.\n\nЧто делать с билдом? Его нужно куда-нибудь **залить**, чтобы он был доступен по **адресу** (ХТТП).\n\nИнтернет делится на несколько вещей, давайте поработаем через аналогии с городом:\n\n- **хостинг** — это библиотека,\n- **домен** — адрес библиотеки,\n- **ДНС** — карта города\n\nХостинг — это сервер, где находится ваш сайт (или база данных, или контр-страйк сервер или ещё что-то).\n\nДомен — адрес к этому серверу.\n\n> Конечно же, на одном сервере может быть несколько доменов привязанных — для этого используют веб-сервер (типа [nginx](https://www.nginx.com/)), который указывает, что по адресу `x.com` нужно показать контент из директории `/www/x.com`, а по адресу `y.com` нужно отправлять запросы на локальное приложение, которое находится на порте 1234. Об этом будем разбирать в следующем уроке.\n\nПо ДНСу браузер (или любой другой клиент) определяет, на какой сервер нужно сходить по домену. ДНС это каталог, так сказать.\n\n---\n\nЧто нам дали эти знания? Нам нужно залить сайт на **хостинг**, к которому будет привязан **домен** через **ДНС**.\n\nНо нас пока эта сложность не очень интересует, нам нужно получить минимальный рабочий результат. Для этого мы возьмём [now.sh](http://now.sh/) — это не совсем хостинг, это некая инфраструктура для разработки: от деплоев до управления ДНС.\n\n### `now`\n\n[Наусш](https://zeit.co/now#get-started) работает очень легко: вы ставите `now` из нпма и затем командой `now deploy [path]` деплоите проект, где `path` — путь к билду.\n\nПример? [mlshv-burberry-fake-shop-for-study.now.sh](https://mlshv-burberry-fake-shop-for-study.now.sh/).\n\nЕсли вы попробуете задеплоить свой проект, вам выдаст поддомен `erodionovru-dyltftawkr.now.sh`, а то и вовсе `build-dyltftawkr.now.sh`.\n\nЧтобы исправить `build` в названии, можно указать опцию `--name`, а для [исправления \"уродского\" поддомена](https://zeit.co/now#whats-now) можно использовать [альясы](https://zeit.co/docs/features/aliases).\n\nНаусш работает по принципу иммутабельных деплоев: если вы что-то задеплоили, то именно за этим деплоем закрепляется уникальный айдишник (именно он и есть уродливый поддомен) — это удобно.\n\nДля постоянного адреса есть альясы, в том числе своего отдельного домена (но понадобится [платный аккаунт](https://zeit.co/pricing) от $15 в месяц).\n\nНасколько Наусш надёжный и подходит для разработки? Ну, этот сайт находится на Наусш :) В серьёзной разработке я бы на него не завязывался, купил бы свой сервер и настроил бы через Докер всё, но в целом приятный сервис.\n\n## Сервисы деплоя\n\nНо, согласитесь, деплоить руками даже через команду `now build` (можно опустить `deploy`, потому что это дефолтная команда и она вызывается при простом `now`) как-то не очень удобно: сначала коммит, потом пуш, потом ещё и задеплоить.\n\nБыло бы удобно, если бы проект сам собирался и деплоился бы при пуше в репозиторий! Такой подход называется Continuous Deployment (на самом деле их аж три: [Continuous integration vs. continuous delivery vs. continuous deployment](https://www.atlassian.com/continuous-delivery/ci-vs-ci-vs-cd)).\n\nОдин из самых популярных публичных и бесплатных для опенсорса сервисов — [Travis CI](https://travis-ci.org/).\n\nТрэвис [работает](https://docs.travis-ci.com/user/for-beginners) по принципу **сценариев**: в YAML-файле (в корне проекта `.travis.yml`) описывается сценарий, который выполняется при каждом коммите.\n\n## Итог\n\nВ этом уроке вы познакомились с билдами, деплоями, окружениями и их параметрами (я про энвы), немного копнули даже в хостинги-днсы и узнали про сервисы деплоя. Хотите задание?\n",
      "isPublic": true,
      "id": "Rb2n4BM9Wr",
      "stageId": "tHKYMIR4QG"
    },
    {
      "stage": 3,
      "title": "Серверный рендеринг",
      "subTitle": "Приходим к бэкэнду фронтэнда",
      "markdown": "В прошлом уроке мы разобрались с билдами и деплоями, но есть одна проблема: а как же нам быть с поисковыми системами?\n\nОни то умеют отрабатывать Джаваскрипт, то не умеют, но нам же нужно надёжное решение, мы не можем надеяться на волю Гугла или Яндекса. Для этого мы будем рендерить приложение на сервере.\n\nКак было раньше, лет 10 назад? Помните, я говорил про MVC? Был проект, который делал запрос к базе данных, затем его рендерил в шаблон и отдавал готовую вёрстку в браузер.\n\nПсевдокодом это выглядит так:\n\n```js\n// подготовленные данные из БД\nconst data = {\n  title: \"2-комнатная квартира в центре Хамовников\",\n  area: 142.2\n};\n\n// шаблон с местами под данные\n<template>\n  <h1>{{data.title}}</h1>\n  <p>{{data.area}} м²</p>\n</template>\n\n// рендер в готовую вёрстку,\n// render не из ReactDOM,\n// а из какого-нибудь шаблонизатора\nconst html = render(data, template);\n```\n\nПо этой причине поисковики (и люди) получали готовую вёрстку и могли её парсить, изучать.\n\nСейчас всё по-другому: поисковикам (и людям) отдаётся небольшой ХТМЛ с `<div id=\"root\"></div>`, куда Реакт рендерит приложение.\n\nНо Реакт-то написан на Джаваскрипте, а поисковики его не исполняют! Всё, что они знают о вашем сайте — это `<div id=\"root\"></div>`. Не очень круто.\n\n## Серверный рендеринг\n\nСерверный рендеринг это процесс рендера приложения на сервере и отдача готовой вёрстки. Как раньше, только у нас не большой проект с бэкэндом и фронтэндом вместе, а небольшой сервер, который занимается только рендером фронтэнда на сервере.\n\nДля чего нужен ССР (server-side rendering)?\n\nВ первую очередь для людей: сервера намного мощнее чем ноутбуки и планшеты людей, поэтому проще подготовить готовую вёрстку и отдать её, чем ждать пока выполнится ваш Джаваскрипт-код. Почитайте про [Ресурс Тайминг](https://developers.google.com/web/tools/chrome-devtools/network-performance/understanding-resource-timing) в блоге Гугла — очень большой простор для оптимизации.\n\nВо вторую очередь для тех самых поисковиков. Поисковый трафик до сих пор остаётся самым сильным, поэтому компании в него вкладываются и будут вкладываться и вы должны очень чутко следить за тем, чтобы ваш новейший фронтэнд работать хорошо.\n\n> Да, если сеошники начинают ныть, что Реакт не приспособлен для СЕО и они не возьмутся за проект — смело им показывайте мой кейс ([29 июня 2017](https://t.me/RodionovRodionovRodionov/207) и полгода спустя, [24 декабря 2017](https://t.me/RodionovRodionovRodionov/474) > ![](https://i.imgur.com/owgyOgP.png)\n\n---\n\nОкей, нужда понятна, как это всё реализовать?\n\n## ХТТП-серверы и Нода\n\nНам же нужно отдавать готовую вёрстку на запрос браузера? Для этого нам нужно написать **сервер**, который будет работать с ХТТП-запросами.\n\nСервер мы будем писать на Джаваскрипте, а запускать — Нодой, которую вы ставили в начале курса.\n\nНода это специальное окружение, где выполняется джс. Нода дарит [свой АПИ](https://nodejs.org/api/index.html) (а браузеры — [свой](https://developer.mozilla.org/en-US/docs/Web/API)), например, для работы с [файловой системой](https://nodejs.org/api/fs.html), [криптографией](https://nodejs.org/api/crypto.html) или [операционной системой](https://nodejs.org/api/os.html) и [путями в ней](https://nodejs.org/api/path.html).\n\nНас интересует [ХТТП](https://nodejs.org/api/http.html), но нативный АПИ слишком низкоуровневый и многосложный, поэтому мы возьмём [Экспресс](http://expressjs.com/) — удобную библиотеку.\n\n> Такие прокладки дают более удобный АПИ, чем нативный, но за это нужно расплачиваться скоростью работы: если бы мы использовали `http` Ноды, у нас бы приложение работало быстрее, потому что Экспресс тоже затрачивает время на выполнение своего кода; это называется **оверхедом**.\n> К счастью, речь идёт о совсем крошечных значениях и в реальной жизни редко кто находит Экспресс узким местом в приложении.\n\nПока мы в браузерах с помощью Бейбеля и Вебпака пришли к `import/export`, модули в Ноде делались (и пока что делаются) через функцию `require()`.\n\nДавайте соберём [небольшую демку](http://expressjs.com/en/starter/hello-world.html) на экспрессе, которая будет на двух разных страницах отдавать разный контент. Код будем писать в `/server.js`\n\n```js\nconst express = require(\"express\");\n\n// создаём приложение\nconst app = express();\n\nconst text = \"Hello World!\";\nconst json = { ok: true };\nconst html = '<html><p style=\"color: red\">test</p></html>';\n\n// при ГЕТ-запросах на разные адреса\n// отдадим разный контент через res.send\napp.get(\"/\", function(req, res) {\n  return res.send(text));\n}\n\napp.get(\"/json\", function(req, res) {\n  return res.send(json));\n}\n\napp.get(\"/html\", function(req, res) {\n  return res.send(html));\n}\n\n// запускаем сервер на порту 3000\napp.listen(3000, function() {\n  console.log(\"Example app listening on port 3000!\");\n});\n```\n\n![](https://i.imgur.com/lexb1aQ.png)\n\nЭкспресс работает на уже знакомых вам коллбеках, в которые приходят два параметра: [`req[uest]`](http://expressjs.com/en/4x/api.html#req) и [`res[ponse]`](http://expressjs.com/en/4x/api.html#res). В реквесте хранится информация о реквесте (например, хедеры, тело, куки и проч), в респонсе — методы и информация о респонсе.\n\n![](https://i.imgur.com/DoIGMWE.png)\n\nЧерез метод [`res.send()`](http://expressjs.com/en/4x/api.html#res.send) мы посылаем ХТТП-ответ. Перед этим мы можем через методы [`res.cookie()`](http://expressjs.com/en/4x/api.html#res.cookie),[`res.set()`](http://expressjs.com/en/4x/api.html#res.set), [`res.status()`](http://expressjs.com/en/4x/api.html#res.status) поставить куки, ХТТП-хедеры или [ХТТП-статус-код](https://httpstatuses.com/).\n\n> Да, этим мы мутируем объект `res`, ну а что поделать — такой вот АПИ у Экспресса. Мутабельность это всё ещё плохо, потому что явное лучше неявного.\n\nКак запустить наш сервер? Командой `node ./server.js`.\n\n---\n\nОкей, что нам дают эти знания? Теперь мы немного умеем работать с ХТТП, понимаем что для этого нужно написать сервер на Ноде с помощью Экспресса.\n\n## Серверный рендеринг — теория\n\nНаша задача отрендерить Нодой Реакт-приложение и затем отдать готовую вёрстку.\n\nПсевдокодом это выглядит примерно так:\n\n```js\nconst express = require(\"express\");\nconst { render } = require(\"react-dom/server\"); // например\nconst ReactApp = require(\"./src/App\");\n\n// создаём приложение\nconst app = express();\n\n// на любом адресе рендерим Реакт-приложение\n// потому что Реакт-роутер разберётся что именно нужно рендерить\napp.get(\"/*\", function(req, res) {\n  // на каждом запросе заново строим Реакт-приложение\n  // потому что у каждого клиента свой запрос\n  const html = render(React.createElement(ReactApp));\n\n  return res.send(html);\n});\n\n// запускаем сервер на порту 3000\napp.listen(3000, function() {\n  console.log(\"Example app listening on port 3000!\");\n});\n```\n\nЧто характерно, этот псевдокод почти рабочий: разве что вместо `render()` из `react-dom/server` мы импортим [`renderToString()`](https://reactjs.org/docs/react-dom-server.html#overview) оттуда же. Фиксанём.\n\n```js\nconst express = require(\"express\");\nconst { renderToString } = require(\"react-dom/server\");\nconst ReactApp = require(\"./src/App\");\n\n// создаём приложение\nconst app = express();\n\n// на любом адресе рендерим Реакт-приложение\n// потому что Реакт-роутер разберётся что именно нужно рендерить\napp.get(\"/*\", function(req, res) {\n  // на каждом запросе заново строим Реакт-приложение\n  // потому что у каждого клиента свой запрос\n  const html = renderToString(React.createElement(ReactApp));\n\n  return res.send(html);\n});\n\n// запускаем сервер на порту 3000\napp.listen(3000, function() {\n  console.log(\"Example app listening on port 3000!\");\n});\n```\n\nЕсли мы теперь каждый запрос будем пропускать через ССР-прокси, то второе, что нам нужно сделать — заменить в `src/index.js` `ReactDOM.render()` на [`ReactDOM.hydrate()`](https://reactjs.org/docs/react-dom.html#hydrate).\n\nНо если мы запустим теперь `node server.js`, то получим кучу ошибок: от `Unexpected token import`.\n\nЕсть два способа это решить: использовать `babel-node` (который будет на лету преобразовывать — но это грозит неплохим оверхедом) и настраивать Вебпак чтобы при билде он собирал отдельный бандл (конечный файл), который вы подключите в Ноду как обычный модуль через `require()`.\n\nВообще, почему так сложно? Почему Нода не поддерживает современный Джаваскрипт? Чисто технически — [поддерживает](https://node.green/), но есть три нюанса.\n\n### Различие Ноды и браузерного Джса\n\n#### Модули\n\nПервый — модули.\n\nРаньше в Джсе вообще никаких модулей не было, потом появился [RequireJS](http://requirejs.org/) который их эмулировал и использовал подход [AMD](http://requirejs.org/docs/whyamd.html) (Asynchronous Module Definition).\n\nБыл ещё CommonJS (он же ServerJS) — спецификация, идея которой была в использовании Джса на серверной стороне, в том числе с модулями. Как вы понимаете, победила Нода, но систему модулей себе она забрала именно оттуда.\n\nПосле — комитет TC39, развивающий Экмаскрипт (стандарт, на котором реализован Джаваскрипт) вернулся к своей работе и каждый год обновляет Экмаскрипт. Самый громкий релиз был ES2015 (он же ES6), частью которого и были модули, или [ES modules](http://2ality.com/2014/09/es6-modules-final.html). Это уже знакомые вам import/export.\n\nПоддержка ес-модулей [будет](https://medium.com/the-node-js-collection/an-update-on-es6-modules-in-node-js-42c958b890c), но, скорее всего, через расширение `.mjs`. Во всяком случае, сейчас её нет.\n\n#### Поддержка ES2015 и выше\n\nВторая проблема — поддержка этого самого Экмаскрипта.\n\nЕсли мы делаем фронтэнд, благодаря Бейбелю мы можем писать современный Джс даже если он недоступен в браузерах. С Нодой современный Джс всё ещё недоступен.\n\nДа, можно компилировать тем же Бейбелем, но плата за это — сложно читаемые исходники. Зайдите на сайт Бейбеля, [попробуйте](http://babeljs.io/repl/) вбить какой-нибудь свой Реакт-код туда — вывод будет сложно понять.\n\n#### Невозможность импорта картинок и прочего\n\nВебпак работает с любым типом файлов — был бы нужный лоадер, хоть [markdown-loader](https://www.npmjs.com/package/markdown-loader), хоть пдф через [file-loader](https://www.npmjs.com/package/file-loader).\n\nВ Ноде, конечно же, такого нет (как и в ес-модулях, в общем-то) — каждый реквайр трактуется как Джс, а не как пнг.\n\n### Решения\n\n#### Сложный: делать отдельный бандл\n\nВ [Купибилете](https://www.kupibilet.ru/) ребята подготавливают отдельный CommonJS-бандл с Реакт-приложением, который потом реквайрят в `server.js`.\n\n**Плюсы:**\n\n* нет оверхеда на преобразование Бейбелем на лету\n\n**Минусы:**\n\n* сложно настроить\n\n#### Лёгкий: использовать `babel-node` вместо `node`\n\n**Плюсы:**\n\n* настроить легче\n\n**Минусы:**\n\n* сильный оверхед: код преобразовывается на каждом запросе и на это уходят ресурсы сервера и время\n\nЛично я использую `babel-node` на этом сайте: у меня не такие большие запросы чтобы думать об оверхеде.\n\n##### `asset-require-hook`\n\nОдин из вопросов настройки это те самые ресурсы типа .жпг или .свг, которые вы импортите и обрабатываете Вебпаком.\n\nДля этого используется [asset-require-hook](http://npm.im/asset-require-hook): специальный модуль, который отлавливает (hook) такие импорты и преобразовывает их в ссылки.\n\nНастройка у него достаточно примитивная:\n\n```js\nrequire(\"asset-require-hook\")({\n  extensions: [\".jpg\", \".jpeg\", \".png\", \".gif\", \".svg\"], // нужны точки обязательно\n  publicPath: process.env.PUBLIC_URL,\n  name: \"/static/media/[name].[hash:8].[ext]\" // https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/config/webpack.config.prod.js#L167\n});\n```\n\n##### `isomorphic-fetch`\n\nВ Ноде нет встроенного Фетча, поэтому используется [node-fetch](http://npm.im/node-fetch), но чтобы не заменять весь проект им, существует ещё один хук: [isomorphic-fetch](http://npm.im/isomorphic-fetch).\n\nПросто импортните его:\n\n```js\nrequire(\"isomorphic-fetch\");\n```\n\n##### `window-or-global`\n\nВ Ноде также нет объекта Window, который существует в браузерах. Для этого используют модуль [window-or-global](http://npm.im/window-or-global), который импортят в Реакт-приложении когда нужно обратиться к `window`.\n\n## Серверный рендеринг — собираем вместе\n\nОкей, мы разобрались с проблемами и нашли решения, давайте соберём всё вместе.\n\nНам нужно на сервере рендерить:\n\n* Реакт — используем `renderToString` из `react-dom/server`,\n* [Реакт-роутер](https://reacttraining.com/react-router/web/guides/server-rendering) — мы же должны отдавать корректную страницу,\n* Заголовки через [react-helmet](https://github.com/nfl/react-helmet#server-usage),\n* Стили через [стайлед-компонентс](https://www.styled-components.com/docs/advanced#server-side-rendering).\n\nДавайте напишем код, который это делает.\n\n```html\n// public/index.html\n\n<!doctype html>\n<html lang=\"ru\">\n\n<head>\n  <meta charset=\"utf-8\">\n\n  // заводим плейсхолдеры\n  // куда будем рендерить стили\n  // и мета-инфу из helmet\n  <meta name=\"$helmet-placeholder$\">\n  <meta name=\"$sc-placeholder$\">\n\n  <style>\n    // скроем, чтобы люди не видели {ssrData}\n\n    .ssr-placeholder {\n      opacity: 0;\n    }\n  </style>\n</head>\n\n<body>\n  <noscript>\n    Сайт без Джаваскрипта работает плохо\n  </noscript>\n\n  <div id=\"root\">\n    // плейсхолдер для основной вёрстки\n    <span class=\"ssr-placeholder\">{ssrData}</span>\n  </div>\n</body>\n\n</html>\n```\n\n```js\n// server/reactApp.js\n// нельзя импортить через require,\n// потому что мы там экспортим через `export`,\n// а не `module.exports` из CommonJS\nimport ReactApp from \"./src/App\";\n\nconst path = require(\"path\");\nconst fs = require(\"fs\");\n\nconst React = require(\"react\");\nconst { StaticRouter } = require(\"react-router-dom\");\nconst ReactDOMServer = require(\"react-dom/server\");\n\nconst { Helmet } = require(\"react-helmet\");\nconst { ServerStyleSheet } = require(\"styled-components\");\n\n// берём build/index.html и сохраняем весь контент в indexFileContent\nconst indexFile = path.resolve(__dirname, \"..\", \"build\", \"index.html\");\nconst indexFileContent = fs.readFileSync(indexFile, { encoding: \"utf8\" });\n\n// плейсхолдер куда будем рендерить данные\nconst ssrPlaceholder = '<span class=\"ssr-placeholder\">{ssrData}</span>';\n\n// плейсхолдер для react-helmet\nconst helmetPlaceholder = '<meta name=\"$helmet-placeholder$\">';\n\n// плейсхолдер для styled-components\nconst scPlaceholder = '<meta name=\"$sc-placeholder$\">';\n\nmodule.exports = (req, res) => {\n  // https://www.styled-components.com/docs/advanced#server-side-rendering\n  // получаем стили\n  const sheet = new ServerStyleSheet();\n\n  // https://reacttraining.com/react-router/web/guides/server-rendering\n  const context = {};\n\n  // приложение с роутером\n  const AppWithRouter = (\n    <StaticRouter location={req.url} context={context}>\n      <ReactApp />\n    </StaticRouter>\n  );\n\n  // получим стили для текущей страницы\n  const AppWithStyles = sheet.collectStyles(AppWithRouter);\n\n  // рендерим в строку\n  const App = ReactDOMServer.renderToString(AppWithStyles);\n\n  // https://github.com/nfl/react-helmet#server-usage\n  // все данные из helmet переводим в строку\n  // и получаем <style> для стайлед-компонентс\n  const helmet = Helmet.renderStatic();\n  const styleTags = sheet.getStyleTags();\n\n  // редиректим с http-кодом 301\n  // если где-то есть <Redirect /> реакт-роутера\n  if (context.url) res.redirect(301, context.url);\n\n  // собираем title, meta, link-теги\n  // в одну строку\n  const helmetData = `\n    ${helmet.title.toString()}\n    ${helmet.meta.toString()}\n    ${helmet.link.toString()}\n  `;\n\n  // вставляем данные через функцию replace\n  // в indexFileContent заменяем все плейсхолдеры\n  const content = indexFileContent\n    .replace(helmetPlaceholder, helmetData)\n    .replace(scPlaceholder, styleTags)\n    .replace(ssrPlaceholder, App);\n\n  // возвращаем тело запроса\n  res.send(content);\n};\n```\n\nИ пишем небольшой сервер на Экспрессе\n\n```js\n// server/index.js\n\n// используем npm.im/debug вместо консольлогов\nconst debug = require(\"debug\")(\"erodionov:server\");\nconst express = require(\"express\");\nconst path = require(\"path\");\n\n// импортим нашу функцию\nconst handleRenderReactApp = require(\"./reactApp\");\n\nconst server = express();\n\n// достаём HOST и PORT энв-параметрами\n// если их нет — ставим дефолтные значения\nconst { HOST = \"127.0.0.1\", PORT = 8080 } = process.env;\n\n// статикой раздаём директорию `build`\n// для картинок и прочего\n// и выключаем через { index: false } использование\n// файла build/index.html\n// иначе Экспресс будет отдавать его на /\nserver.use(\n  express.static(path.resolve(__dirname, \"..\", \"build\"), { index: false })\n);\n\n// на любой запрос вызываем функцию handleRenderReactApp\nserver.get(\"/*\", handleRenderReactApp);\n\nserver.listen(PORT, HOST, () => debug(`app started at ${HOST}:${PORT}`));\n```\n\nЗапускаем как `PUBLIC_URL=https://erodionov.ru babel-node server/index.js` и вуаля, всё работает!\n\n## Итог\n\nДа, серверный рендеринг это и легко и сложно одновременно: что-то могло быть легче, но в целом это не какая-то шаманская магия, всё вполне очевидно решается.\n\nНу и заодно мы в начале урока разобрались с ХТТП и Нодой!\n\n> PS: публичный код этого сервернего рендеринга я храню в [gist.github.com](https://gist.github.com/evgenyrodionov/d29ab267c2c18d16b37377ca6c30232b)\n",
      "isPublic": true,
      "id": "HpQvjr5ieg",
      "stageId": "tHKYMIR4QG"
    },
    {
      "stage": 3,
      "title": "Типизация через Флоу",
      "subTitle": "Делаем Джаваскрипт чуть более надёжным языком",
      "markdown": "Джаваскрипт в целом неплохой язык: хоть у него много проблем, он развивается и с приходом релизов [ES2015](http://babeljs.io/learn-es2015/) (и выше) он стал реально удобным.\n\nНо у него есть несколько родовых проблем, которые мешают разработке.\n\n* **отсутствует семантика**: для проверки на тип есть глобальная функция `isNaN(x)`, метод массива `Array.isArray(x)` и оператор `typeof x`;\n\n* **плохие неочевидные слабые динамические типы**: посмотрите великое видео [WAT](https://www.destroyallsoftware.com/talks/wat), а потом прочтите [Как унизить джаваскриптера](https://medium.com/@vkozulya/e0aa256a8905)\n\n* **омерзительная работа с датами**: спустя года разработки лично я до сих пор не могу вспомнить когда использовать `new Date()`, а когда просто `Date()`; к счастью, эту проблему решает [date-fns](http://date-fns.org/)\n\n* **очень слабая стандартная библиотека**, поэтому приходится использовать [lodash](https://lodash.com/), благо что он модульный.\n\n* **слабая консистентность**: метод [`Array.prototype.slice()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice) (возвращает отрезанный кусок массива) не мутирует оригинальный массив, а [`Array.prototype.splice()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice) (вставляет элемент в массив) — мутирует.\n\nНо Джаваскрипт-то развивается, а то, что нельзя исправить в спецификации (из-за обратной совместимости) — исправляется сообществом с помощью транспайлеров (помните про [Бейбель](http://babeljs.io/)?).\n\nПроблему с типами решил Фейсбук с помощью [Флоу](https://flow.org/). _А Майкрософт — [Тайпскриптом](https://www.typescriptlang.org/)._\n\n## Флоу\n\nЗачем вообще нужно работать с типами?\n\nНа системном уровне — чтобы компилятор делал за вас проверки, а не вы в продакшене узнавали о том, что что-то сломалось (например, с помощью [Сентри](https://sentry.io/)).\n\nНа бытовом: текстовый редактор показывает что нужно передать в функцию и что она вернёт — не нужно самому помнить.\n\n![](https://i.imgur.com/oHM9D5E.png)\n\nВажно понимать: если вы будете писать типы, это вначале замедлит разработку, но окупится позже.\n\n[Начать работать](https://flow.org/en/docs/getting-started/) (и [интегрировать](https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-flow) в react-scripts) с Флоу легко:\n\n1.  ставите в проект [`flow-bin`](http://npm.im/flow-bin),\n2.  запускаете команду `yarn flow init` чтобы создать [`.flowconfig`](https://flowtype.org/docs/advanced-configuration.html),\n3.  в каждом файле который вы хотите обложить тестами, добавляете первой строчкой `// @flow`,\n4.  запускаете `yarn flow` (например, на этапе билда),\n5.  читаете ошибки и исправляете их!\n\nВ Вскоде поставьте [Flow Language Support](https://marketplace.visualstudio.com/items?itemName=flowtype.flow-for-vscode).\n\n## Как писать свои типы\n\nДа легко: у аргумента функции пишете её [тип](https://flow.org/en/docs/types/), а после аргументов — что она вернёт.\n\n```js\nfunction square(n: number): number {\n  return n * n;\n}\n\nsquare(\"2\"); // Error!\n```\n\n## Где искать типы к чужим библиотекам\n\nДопустим, вы используете готовую библиотеку — [react-helmet](https://npm.im/react-helmet) или [react-intl](https://npm.im/react-intl), но они не поставляют типы. Этим вообще редко кто занимается.\n\nПоэтому существует [flow-typed](https://github.com/flowtype/flow-typed): центральный репозиторий с типами к библиотекам из Нпма.\n\nРаботать с ним легко:\n\n1.  ставите Ярном `flow-typed` (это CLI) в проект;\n2.  запускаете через `yarn flow-typed`: он установит типы для пакетов из `package.json`;\n3.  добавляете директорию `flow-typed` в `.gitignore`, а то репозиторий превратится в мусорку.\n\nВсё! Теперь вам доступны [типы флоу-тайпед](https://github.com/flowtype/flow-typed/wiki/Importing-And-Using-Type-Definitions). Импортите их и носите на здоровье.\n\n## Итог\n\nВ этом уроке вы познакомились с Флоу — системой проверки типов в Джаваскрипте, да и с самими типами тоже познакомились.\n\nКакой вывод? Типы важны, но они замедляют начальную разработку.\n\nКстати, если вам интересно — погрузитесь в то, как [устроен](https://flow.org/en/docs/lang/) Флоу.\n",
      "isPublic": true,
      "id": "vzgNWlOPx5",
      "stageId": "tHKYMIR4QG"
    },
    {
      "stage": 3,
      "title": "Паттерны: от Higher-Order Components до Render Props",
      "subTitle": "Вместо собственных велосипедов давайте использовать уже готовые подходы",
      "markdown": "# Паттерны Реакта\n\n> Вместо собственных велосипедов давайте использовать уже готовые подходы\n\n## [Conditional Rendering](https://reactjs.org/docs/conditional-rendering.html)\n\nНачнём, на удивление, с самого простейшего вопроса: как отрендерить кусок в зависимости от проверки?\n\nКак вы помните, Джсх это всё равно что Джс, поэтому в самом примитивном варианте просто вставьте ифы и ретёрны.\n\n### Примитивный вариант\n\n```jsx\nif (x) return <TruthyComp />;\n\n// вернется если проверка на x\n// не отработала в true\nreturn <FalsyComp />;\n```\n\nНу или тернарный оператор `?:`\n\n```jsx\nreturn x ? <TruthyComp /> : <FalsyComp />;\n```\n\n### [Инлайновые проверки](https://reactjs.org/docs/conditional-rendering.html#inline-if-with-logical--operator)\n\nЧто делать, если у вас большой компонент (не надо так) и нужно по условию отрендерить какой-то блок? Допустим, кнопку. Просто поместите проверку через оператор `&&` в `{}`.\n\n```jsx\nfunction Mailbox(props) {\n  const unreadMessages = props.unreadMessages;\n  return (\n    <div>\n      <h1>Hello!</h1>\n      {unreadMessages.length > 0 && (\n        <h2>You have {unreadMessages.length} unread messages.</h2>\n      )}\n    </div>\n  );\n}\n```\n\nКак замечено в официальной документации, такое возможно, потому что в Джаваскрипте выражение `true && expression` выполнит `expression`, а `false && expression` выполнит `false`.\n\n## Частичные компоненты\n\nСоздаёте компонент вокруг другого компонента, передав ему какой-то набор пропов.\n\n```jsx\nconst Button = props =>\n  <button type=\"button\" {...props}>\n\n<Button />\n// <button type=\"button\"><button>\n\n<Button className=\"CTA\">Send Money</Button>\n// <button type=\"button\" class=\"CTA\">Send Money</button>\n```\n\n## [Children-as-a-function или render prop](https://reactjs.org/docs/render-props.html)\n\nЧилдрен может быть функцией. Знали?\n\n```jsx\nclass Auth extends React.Component {\n  state = {\n    isLoggedIn: false,\n    userId: 1\n  };\n\n  render() {\n    const { isLoggedIn, userId } = this.state;\n\n    return this.props.children({ isLoggedIn, userId });\n  }\n}\n\nfunction Lesson(props) {\n  return (\n    <View>\n      <h1>{props.title}</h1>\n\n      <Auth>\n        {function({ isLoggedIn, userId }) {\n          if (isLoggedIn) {\n            return props.lesson;\n          }\n\n          // возвращаем превью урока если человек не залогинен\n          return props.preview;\n        }}\n      </Auth>\n    </View>\n  );\n}\n```\n\nТот же самый паттерн используется в [рендер пропе](https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce): просто вместо чилдрен используется проп `render` и код выглядит как `<Auth render={function() {...}} />`.\n\n## [Higher-order Component](https://reactjs.org/docs/higher-order-components.html)\n\nЕщё один способ передать пропы из одного компонента в другой: HoC.\n\nHoC — это функция, в которую приходит компонент и которая возвращает другой компонент.\n\nИз примеров: `connect()` в react-redux и `withRouter()` в Реакт-роутере.\n\n```jsx\nfunction withAuth(Comp, options = {}) {\n  return class extends React.Component {\n    state = {\n      isLoggedIn: false,\n      userId: 1\n    };\n\n    render() {\n      const { isLoggedIn, userId } = this.state;\n\n      return <Comp isLoggedIn={isLoggedIn} userId={userId} />;\n    }\n  };\n}\n\nfunction Lesson(props) {\n  return (\n    <View>\n      <h1>{props.title}</h1>\n\n      {this.props.isLoggedIn ? props.lesson : props.preview}\n    </View>\n  );\n}\n\nconst LessonWithAuth = withAuth(Lesson);\n```\n\nВ чём отличие от рендер пропа? В том, что менее явное поведение: в рендер пропе обычная функция с набором аргументов, а тут в пропы нашего компонента спускаются неизвестные пропы.\n\n## Родитель-ребенок\n\nЗдесь оставлю ссылку на [пост](https://medium.com/@jmuse/d86394da2b50) Юли, которая проходила курс: она расписала модели «родитель → ребенок», «ребенок → родитель» и «ребенок → ребенок».\n\n## Итог\n\nПаттерны нужны, чтобы не плодить свои велосипеды и не усложнять себе (и другим разработчикам!) жизнь.\n\nИспользуйте всё кроме HoC — за лаконичность их АПИ расплачиваетесь неочевидностью пропов.\n",
      "isPublic": true,
      "id": "nxvBdqk3uu",
      "stageId": "tHKYMIR4QG"
    },
    {
      "stage": 3,
      "title": "Что дальше",
      "subTitle": "Завершаем курс и строим планы на будущее",
      "markdown": "> В планах был урок про тестирование, но лично я, Евгений Родионов, никогда не писал тесты: мне было достаточно Еслинта и Флоу, чтобы мой код стабильно работал.\n> Если вы эксперт в тестировании под Реакт — напишите мне, мы бы выпустили бонусным уроком.\n\nИтак, прошло 19 уроков: от открытого первого этапа и первого задания до последнего про паттерны.\n\nЧто делать дальше?\n\nВо-первых, **закончите проект**: крепкая теория это лишь малая часть пользы, самая большая работа происходит на практике.\n\nВо-вторых, **сдайте** проект: вам нужно получить фидбэк и найти свои слабые места.\n\nВ-третьих, **получите** второе задание на паттерны, стейты и работу с АПИ.\n\nВ-четвертых, **добавляйтесь в Курсач**: одному скучно, а у нас есть коммьюнити разработчиков. Для Курсача нужно сдать проект.\n\nЭто то, что относится к курсу. А что дальше?\n\n---\n\nДальше стоит разобраться в своих слабых местах.\n\nЕсли страдает вёрстка, то подтяните вёрстку: это же основа фронтэнда, основа интерфейсов.\n\nЕсли вёрстка после этого (и только после этого) не нравится — можно задуматься о смене деятельности, вдруг вам интереснее работать с данными: возьмите [Machine Learning](https://vas3k.ru/blog/machine_learning/), изучите сферу больших данных.\n\nНравится строить системы — возьмите бэкэнд, нравится безопасность — идите в инфобезопасность.\n\nСпрос везде огромный. Главное правило — не быть мудаком и знать [культуру работы](https://www.youtube.com/evgenyrodionov).\n\n---\n\nДо новых встреч! Жду ваши проекты.\n\nЕвгений Родионов.\n\n![](https://i.imgur.com/2BlZUYN.png)\n",
      "isPublic": true,
      "id": "x39l7BIALs",
      "stageId": "tHKYMIR4QG"
    }
  ]
}