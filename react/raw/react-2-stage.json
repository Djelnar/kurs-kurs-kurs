{
  "stageName": "Этап второй: базовый Реакт",
  "lessons": [
    {
      "stage": 2,
      "title": "Стейты компонентов как источник данных",
      "subTitle": "В компонентном подходе компонентны не только рендер и стили, но и логика",
      "markdown": "# Принципы Реакта\n\n<iframe width=\"100%\" height=\"541\" src=\"https://www.youtube.com/embed/f11f8ksArp4\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe>\n\n# Эвенты, классовые компоненты, this и стейт\n\n<iframe width=\"100%\" height=\"541\" src=\"https://www.youtube.com/embed/eQyGf8Fe_YQ\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe>\n\n# Работа с данными\n\n<iframe width=\"100%\" height=\"541\" src=\"https://www.youtube.com/embed/tj3wrvHdyuo\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe>\n\nОкей, с вёрсточкой разобрались: поняли, как верстать компонентами, переехали с селекторов на Стайлед-компонентс, поиграли с Реакт-роутером, но пора двигаться дальше.\n\nГде хранить данные? Как с ними работать? Нужно ли писать сервис-провайдеры-фабрики как в Ангуларе?\n\n## Стейты\n\nСлава богу, не нужно! Реакт несложный даже в работе с данными и оперирует обычными функциями, которые возвращают новые данные.\n\nКак работает Реакт? У компонента есть **стейт** — состояние данных, есть **рендер** — вёрстка, в сумме это то самое уравнение `ui = render(state)` из первого урока.\n\nЧто это значит? **Когда обновляется стейт, вызывается рендер и строится новый интерфейс**.\n\nДа, само. Да, нужно всего лишь обновить стейт, рендер сам вызовется. Да, это так удобно.\n\nДа, если вы хотите поставить кнопке красный цвет, не нужно писать `document.getElementById(\"my-button\").style.background = 'red'`, достаточно просто поставить новый стейт.\n\nДа, если вы хотите чекбоксу поставить `checked`, можно в стейт положить `checked: true` и передать пропом `checked={state.checked}`.\n\nДа, в стейте можно хранить даже данные с сервера.\n\nДа, в стейте хранят и данные заполненных форм.\n\nДа, это работает как на маленьких проектах, так и на крупных.\n\nДа, Редакс уже близко. Редакс это всего лишь глобальный стейт, а не компонентный.\n\n### Посортируем список фильмов\n\nЧто такое стейт? Это просто объект с данными, к которому можно обратиться. Давайте в виде псевдокода представим что у нашего компонента есть стейт.\n\n```jsx\nconst state = {};\n\n// рендерим\nfunction Movies() {\n  return (\n    <div>\n      <p>Sort by:</p>\n      <button>alphabetical</button>\n      <button>date released</button>\n      <button>reviews count</button>\n      <button>average rating</button>\n      ...movies list\n    </div>\n  );\n}\n```\n\nВ этом стейте мы можем хранить данные. Почему в стейте, а не просто константой? **Стейт — для динамических данных**, а в интерфейсе у нас есть сортировка фильмов.\n\nОбновилась сортировка → обновился список фильмов → обновился интерфейс.\n\nКаждой кнопке мы добавим проп `onClick`, внутри которого будет функция, которая будет вызывать нашу функцию `handleClick` и передавать туда поле, по которому нужно отсортировать. Заодно наполним стейт начальными данными.\n\n```jsx\nconst state = {\n  movies: [\n    {\n      id: 1,\n      title: \"City Lights\",\n      year: 1931,\n      rating: 8.5\n    },\n    {\n      id: 2,\n      title: \"American History X\",\n      year: 1998,\n      rating: 8.5\n    },\n    {\n      id: 3,\n      title: \"Wild Strawberries\",\n      year: 1957,\n      rating: 8.1\n    }\n  ]\n};\n\nfunction changeSort(kind) {}\n\n// рендерим\nfunction Movies() {\n  return (\n    <div>\n      <p>Sort by:</p>\n      <button onClick={() => changeSort(\"alphabetical\")}>alphabetical</button>\n      <button onClick={() => changeSort(\"date\")}>date released</button>\n      <button onClick={() => changeSort(\"rating\")}>average rating</button>\n      ...movies list\n    </div>\n  );\n}\n```\n\nТеперь давайте представим, что у нас есть некая магическая функция `setState`, которая принимает в себя данные и обновляет стейт.\n\nПричем, что удобно, обновляет только указанные данные: например, если у вас в стейте три поля `isFetching, movies, error`, а вы вызовете `setState({ isFetching: true })`, то `movies` и `error` останутся такими же, какими и были.\n\nОкей, у нас есть эта функция, давайте теперь напишем нашу функцию `changeSort()`:\n\n```js\n// заведём функцию сортировки\n// https://davidwalsh.name/array-sort\nfunction sortObjectsByField(field, leftObject, rightObject) {\n  return leftObject[field] - rightObject[field];\n}\n\nfunction changeSort(kind) {\n  // заведём объект,\n  // который будет приводить\n  // kind к полю у объекта\n  const sortFieldsToKey = {\n    alphabetical: \"title\",\n    date: \"year\",\n    rating: \"rating\"\n  };\n\n  // получим поле у объектов,\n  // по которому нужно сортировать\n  const currentSortField = sortFieldsToKey[kind];\n\n  // сохраним текущее поле\n  // чтобы подсветить кнопку активным\n  // ЭТА ФУНКЦИЯ ПРИДУМАНА, ЕЁ НЕ СУЩЕСТВУЕТ\n  setState({ orderField: kind });\n\n  // отсортируем фильмы\n  setState({\n    movies: state.movies.sort(function(leftObj, rightObj) {\n      return sortObjectsByField(currentSortField, leftObj, rightObj);\n    })\n  });\n}\n```\n\nЧто дальше? В рендере мы просто [выведем](https://reactjs.org/docs/lists-and-keys.html) эти фильмы через метод `.map()` у массива.\n\nЭтот метод проходится по массиву, на каждом элементе вызывает функцию, которая должна вернуть новое значение под этим же индексом массива, в нашем случае — Реакт-компонент.\n\n_Если тут ничего непонятно — перечитайте третий урок про базовый джаваскрипт._\n\n```jsx\nfunction Movies() {\n  return (\n    <div>\n      <p>Sort by:</p>\n      <button onClick={() => changeSort(\"alphabetical\")}>alphabetical</button>\n      <button onClick={() => changeSort(\"date\")}>date released</button>\n      <button onClick={() => changeSort(\"rating\")}>average rating</button>\n\n      {state.movies.map(function(movie) {\n        // movie это объект с данными\n\n        // возвращаем Реакт-компонент\n        return (\n          <a href={`/movies/${movie.id}`} key={movie.id}>\n            {movie.title} ({movie.year}) | rating {movie.rating}\n          </a>\n        );\n      })}\n    </div>\n  );\n}\n```\n\n> Что ещё за фигурные скобки? Это Джсх, в фигурных скобках [может быть](https://reactjs.org/docs/introducing-jsx.html#embedding-expressions-in-jsx) любое Джс-выражение: хоть `2 + 2`, хоть обращение к объекту `user.firstName`, хоть вызов функции `formatName(user)`.\n\n> Что за проп `key`? Это [обязательный](https://reactjs.org/docs/lists-and-keys.html#keys) у списков проп, который помогает Реакту отделить один компонент от другого при обновлении данных. Реакт справится и без них, но лучше с ними.\n\nМы же прошлись по массиву и получили новый массив, в котором есть Реакт-компоненты. Их мы и отрендерили.\n\nЕсли упрощать до обычного Джаваскрипта, мы могли бы новый массив закрепить за константой и обратиться к ней в Джсхе:\n\n```jsx\nfunction Movies() {\n  const movies = state.movies.map(function(movie) {\n    // movie это объект с данными\n\n    // возвращаем Реакт-компонент\n    return (\n      <a href={`/movies/${movie.id}`} key={movie.id}>\n        {movie.title} ({movie.year}) | rating {movie.rating}\n      </a>\n    );\n  });\n\n  return (\n    <div>\n      {/* кнопки сортировки */}\n\n      {movies}\n    </div>\n  );\n}\n```\n\nВ итоге мы будем рендерить список фильмов, а при клике на сортировку — сортировать его и автоматически обновлять стейт, потому что у нас есть вымышленная функция `setState()`: от неё зависит Реакт и обновляет рендер сразу же после того как обновится стейт.\n\n## Итог\n\nНа этом наш урок подходит к концу.\n\nСегодня мы разобрались с тем, как у компонентов могут быть стейты, в которых хранятся и обновляются данные через `setState()`.\n\nВажно помнить, что всю работу по обновлению интерфейса Реакт берёт на себя, наша задача — писать стейт, обновлять его и описать в рендере вёрстку от этого стейта.\n\n---\n\nКстати, а как быть, если хочется не ссылку рендерить через `<a>`, а свой компонент? Как туда передать стейт?\n\nПропами!\n\n```jsx\nfunction Movie(props) {\n  return (\n    <a href={`/movies/${props.id}`}>\n      {props.title} ({props.year}) | rating {props.rating}\n    </a>\n  );\n}\n\nfunction Movies() {\n  const movies = state.movies.map(function(movie) {\n    // movie это объект с данными\n\n    // возвращаем Реакт-компонент\n    return (\n      <Movie\n        id={movie.id}\n        year={movie.year}\n        rating={movie.rating}\n        key={movie.id}\n      >\n        {movie.title}\n      </Movie>\n    );\n  });\n\n  return (\n    <div>\n      {/* кнопки сортировки */}\n\n      {movies}\n    </div>\n  );\n}\n```\n",
      "isPublic": true,
      "id": "pN52548BH1",
      "stageId": "rHAh7OXEFL"
    },
    {
      "stage": 2,
      "title": "Работа человека с интерфейсом через эвенты",
      "subTitle": "Интерфейс это не статичная картинка, но как понять что человек делает с ним?",
      "markdown": "Привет! Девятый урок и мы подбираемся к настоящему фронтэнду — передней части продукта, так сказать. Не вёрстке (пускай и на Реакте со СК и Роутером), а именно что фронтэнду.\n\nНо для начала — пару обязательных технических знаний.\n\n## Дев тулз\n\nЕсли вы уже начали экспериментировать с кодом, то вы, наверное, заметили, что вслепую сложно что-то делать.\n\nЛюди с [курса по вёрстке](https://erodionov.ru/courses/verstka) знают про [дев тулз](https://developers.google.com/web/tools/chrome-devtools/) — специальная утилита браузера, которая показывает дерево элементов и его стили.\n\nВо всех современных браузерах (от Эджа до Хрома и Сафари) есть ДевТулз — инструменты разработчика. Обычно они делятся на кучу вкладок, но нас интересуют две: дерево элементов и консоль.\n\nВ консоль можно писать через функцию `console.log()`.\n\n![](https://i.imgur.com/NWwEdQI.png)\n\nДля Хрома и Файрфокса поставьте [Реакт ДевТулз](https://github.com/facebook/react-devtools), тогда у вас будет доступ ещё и к компонентам с их стейтами и пропами. Удобно.\n\n## ДОМ или дерево элементов\n\nНа [ДОМе](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction) (DOM, Document Object Model) построена вся работа браузеров. ДОМ, как вы понимаете, это **дерево элементов**, а Виртуал ДОМ — это технология, работающая с двумя деревами: она сравнивает их между собой и вычленяет маленькие изменения, чтобы экономно обновить ДОМ.\n\nА как, кстати, работать с реальным ДОМом? Это же не магия какая-то, которая доступна только разработчикам библиотек типа Реакта. Веб вообще славится своей открытостью: всем доступно всё.\n\nРабота с ДОМом **императивна**: вы должны указать \"возьми этот элемент и сделай с ним что-нибудь\".\n\nРабота с элементами в Реакте **декларативна**: вы указываете \"у этого элемента такие свойства\".\n\nНепонятно? Согласен. Давайте разбирать на примерах.\n\n## Эвенты\n\nЕсли человек куда-то кликнул, проскроллил или ещё что-то сделал с интерфейсом, как это отследить? Как поставить хотя бы консоль.лог на это событие?\n\n[Событие](https://developer.mozilla.org/en-US/docs/Web/Events)! Вот как работает интерфейс: на событиях, эвентах. Произошло событие — мы должны его **обработать**. Как это лучше всего сделать? Наверное, функцией? Вызвать функцию когда произошло событие — это звучит логично.\n\nТак оно и есть: когда происходит эвент, вызывается его хэндлер (обработчик). Хэндлер эвента это функция, в которую приходят аргументы, в этой функции мы делаем что-нибудь с эвентом, хоть консоль.логом выводим.\n\nСудя по [МДН](https://developer.mozilla.org/en-US/docs/Web/Events), эвентов очень много, но мы будем рассматривать два простейших: клик по элементу и, допустим, фокус по инпуту.\n\n> Кстати, если вам интересно, почему я не перевожу термины — чтобы вам было проще с ними работать и гуглить информацию по ним.\n\n> Почитывая в прошлом Хабрахабр, я заметил идиотские переводы простейших терминов и не понимал даже как гуглить о чём идёт речь.\n\n### Работа с эвентами в браузерном Джсе\n\nКак я и говорил, в браузерном Джсе мы работаем императивно: берём элемент и вешаем на него хэндлер.\n\n```html\n<button id=\"my-button\">click me</button>\n\n<script>\n  // ищем элемент через document.getElementById()\n  // https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById\n  const button = document.getElementById(\"my-button\");\n\n  // вешаем на него клик\n  button.addEventListener(\"click\", function(event) {\n    // при клике выводим в консоль данные эвента\n    console.log(event);\n  });\n</script>\n```\n\nСкажем так, выглядит не очень удобно. А что если мы сможем указать прямо у элемента атрибут onClick и туда передать функцию?\n\nИ [мы можем](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Events): существуют три вида работы с эвент хэндлерами и `addEventListener` как раз один из них.\n\nКакой второй способ? Через атрибут `onclick` указать функцию и что в неё придёт:\n\n```html\n<button onclick=\"handleMyButtonClick(event)\">\n  click me\n</button>\n\n<script>\n  function handleMyButtonClick(event) {\n    console.log(event);\n  }\n</script>\n```\n\nВыглядит уже намного лучше и понятнее, верно? Этот путь находится очень рядом с системой эвентов Реакта.\n\n### Работа с эвентами в Реакте\n\nВ примере выше есть несколько проблем:\n\n1.  непонятный стиль кода вместо camelCase (`onClick` читается легче чем `onclick`),\n2.  функция зачем-то передаётся как строка,\n3.  функция как будто вызывается прямо в атрибуте, но на деле нет,\n4.  нет системы ошибок: если забыл объявить `handleMyButtonClick`, то пользователь узнает об этом только при клике на кнопку, хотя Еслинт мог бы подсветить что такой функции нет.\n\nВсе четыре проблемы решил Реакт через лозунг \"явное лучше неявного\". С первым пунктом всё понятно, давайте пройдёмся по остальным трём.\n\n#### Функция передаётся как функция, а не строка\n\nМы знаем, что в Джсхе мы можем выполнять любой Джс-код в `{}`: хоть `{2+2}`, хоть `{getUserInfo(userId)}`. Пропы тоже поддерживают этот синтаксис:\n\n```jsx\nimport React from \"react\";\nimport styled from \"styled-components\";\n\nconst Button = styled.button`\n  // умножим размер на 10\n  // чтобы получить размер паддингов\n  padding: ${props => p.size * 10}px;\n`;\n\n<Button size={2 + 2}>Button of 4</Button>;\n```\n\nПо этой причине мы на клик по кнопке можем передать функцию.\n\n```js\n// Button.js\nfunction handleClick(event) {\n  console.log(event);\n}\n\n<button onClick={handleClick(event)}>click me</button>;\n```\n\nНо стоп! Стоп-стоп-стоп! Если мы так сделаем, откроем страницу, то даже без клика мы получим консоль.лог в браузере.\n\n<iframe src=\"https://codesandbox.io/embed/k3kp4l0p8v\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\nКак так?\n\n#### Функция не должна вызываться в пропе\n\nВ проп должна передаться ссылка на функцию, а не её вызов.\n\n```jsx\n// неправильно — вызовется сразу как компонент станет доступен\n<button onClick={handleClick(event)}>click me</button>\n\n// правильно — при клике на элемент вызовется эта функция\n<button onClick={handleClick}>click me</button>\n```\n\n> Как понять, что в Реакте приходит на этом `onClick`? Читайте официальную документацию: [Handling Events](https://reactjs.org/docs/handling-events.html) и [`SyntheticEvent`](https://reactjs.org/docs/events.html).\n> Первая статья рассказывает о работе эвентов, вторая — о специальном типе данных `SyntheticEvent`, который отличается от дефолтного объекта браузера, который приходит в хэндлере эвента.\n\nЧетвёртая проблема, как вы понимаете, тоже решена: мы в Джсхе передаём обычный джаваскрипт, поэтому если наша функция не будет существовать, то Еслинт об этом расскажет — либо в редакторе (если вы настроили интеграцию), либо при сборке проекта (об этом в будущем).\n\n## Итог\n\nВ этом уроке мы не только разобрались с системой эвентов в Реакте и поняли чем она мощна, но и поработали с браузерными ДОМом и эвентами.\n\nА говорят, что не нужно начинать знакомство с фронтэндом через популярные библиотеки и фреймворки! Как видите, мы учимся _чистому Джсу_ как раз потому что Реакт не использует свой птичий язык шаблонов и заставляет работать с чистым Джсом.\n\nКстати, как попрактиковаться в этих знаниях? Отловили мы эвент, дальше-то что? Узнаете в следующем уроке — там мы будем соединять стейт и эвенты.\n",
      "isPublic": true,
      "id": "oYajvJsdaa",
      "stageId": "rHAh7OXEFL"
    },
    {
      "stage": 2,
      "title": "Лайфсайкл-методы и классовые компоненты по Марксу",
      "subTitle": "Возвращаемся к стейтам и погружаемся немного в ООП чтобы поработать с ними и лайфсайкл-методами",
      "markdown": "## Лайфсайкл-методы\n\nОкей, поняли что интерфейс от простого макета отличает **интерактивность**: человек может с ним взаимодействовать и фронтэнд должен обрабатывать эти **события**.\n\nНо что делать, если нам в Реакте нужны события, которые не очень зависят от действий людей? Например, с компонентом что-то произошло и это нужно отследить? Как это сделать?\n\nДля этого есть **лайфсайкл-методы компонента**: те методы, которые вызываются во время **его жизни**. Этих всадников апокалипсисов аж целых восемь и из их названий понятно, когда они вызываются:\n\n### Маунтинг и анмаутинг\n\nМаунтинг (mounting) это момент, когда компонент, скажем так, _собирается_. Для этих состояний есть три стейта:\n\n* [`componentWillMount()`](https://reactjs.org/docs/react-component.html#componentwillmount)\n* [`render()`](https://reactjs.org/docs/react-component.html#render) (да, рендер по сути это тоже лайфсайкл-метод!)\n* [`componentDidMount()`](https://reactjs.org/docs/react-component.html#componentdidmount)\n* [`componentWillUnmount()`](https://reactjs.org/docs/react-component.html#componentwillunmount)\n\n### Апдейты\n\n_(список расположен по порядку вызова лайфсайклов)_\n\n* [`componentWillReceiveProps(nextProps)`](https://reactjs.org/docs/react-component.html#componentwillreceiveprops)\n* [`shouldComponentUpdate(nextProps, nextState)`](https://reactjs.org/docs/react-component.html#shouldcomponentupdate) — метод, в котором можно решить, нужно ли вызывать ре-рендер (обычно используется для оптимизаций)\n* [`componentWillUpdate(nextProps, nextState)`](https://reactjs.org/docs/react-component.html#componentwillupdate)\n* [`render()`](https://reactjs.org/docs/react-component.html#render)\n* [`componentDidUpdate(prevState, prevProps)`](https://reactjs.org/docs/react-component.html#componentdidupdate)\n\n### Ошибки\n\nРеакт бросит ошибку, если он не сможет построить интерфейс (например, вы ошиблись в типах и пытаетесь сделать `.map()` по объекту), но как эту ошибку отловить? Лайфсайклом.\n\n* [`componentDidCatch(error, info)`](https://reactjs.org/docs/react-component.html#componentdidcatch)\n\nЧто с ней потом делать? Можно в стейт поставить `error: true` и пользователю показать плашку «Сорян, произошла ошибка», а саму ошибку поймать в какой-нибудь сервис типа [Sentry](http://sentry.io/) или [Bugsnag](https://www.bugsnag.com/).\n\n```jsx\n// src/Movies/index.js\nimport React from 'react';\nimport bugsnag from 'bugsnag';\n\nimport Movies from './List';\nimport { Alert } from '../ui';\n\nclass extends React.Component {\n  componentDidCatch(error, info) {\n    bugsnag.notify(error);\n  }\n\n  render() {\n    return (\n      <section>\n        <Alert>\n          Произошла ошибка, мы уже отправили сообщение разработчикам\n        </Alert>\n\n        <Movies data={data} />\n      </section>\n    )\n  }\n}\n```\n\n> Кстати, у Багснега есть даже специальный [компонент](https://docs.bugsnag.com/platforms/browsers/react/) для [Error Boundaries](https://reactjs.org/docs/error-boundaries.html) — это концепт работы ошибок, который [появился в Реакте 16](https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html).\n\nНо что это за синтаксис странный? Почему мы написали функцию `componentDidCatch() {}` без `function`, да ещё и обернули в `class`?\n\n## Классы 👍🏻\n\nВ позапрошлом уроке мы говорили про стейты, но там мы работали с псевдокодом — да, я действительно не показал реальный код, потому что для этого было рано. Сейчас — самое время.\n\nОкей, вот мы работаем с компонентом и всё понятно, когда речь идёт про вёрстку: возвращай через `return` Джсх, Реакт построит интерфейс из всех компонентов.\n\nНо что делать со стейтами? Или лайфсайклами? Если функции это просто вызываемый кусок кода, то куда это всё впихнуть? Где хранить стейт? Как подписаться на лайфсайклы?\n\nДля этого есть классы — специальные объекты, в которых могут быть **методы** и **поля**. Пример?\n\n```jsx\nclass Rectangle {\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n\n  calcTotal() {\n    return this.height * this.width;\n  }\n}\n\nconst square = new Rectangle(10, 10);\n\nconsole.log(square); // Rectangle { width: 10, height: 10 }\nconsole.log(square.calcTotal()); // 100\n```\n\nНадо разбираться!\n\n---\n\nКлассы пришли из объекто-ориентированного программирования — подхода, со временем показавшего свою несостоятельность перед функциональным программированием.\n\nНо не верьте мне на слово, а то потом на собеседованиях будете отвечать «ООП говно потому что Родионов так говорит», что, по сути, карго-культ слепой. Попробуйте оба подхода и вернитесь к ФП. Красноречивее всего, конечно, этот слайд из выступления [Functional Programming Design Patterns](https://fsharpforfunandprofit.com/fppatterns/).\n\n![](https://i.imgur.com/PlXT59O.png)\n\nЭтот слайд говорит о том, что пока люди в ОО придумывают новые паттерны программирования, люди в ФП просто пишут код на функциях и не устраивают баталии «этот код нужно писать на фактори паттерне, а не на визитор!» на код-ревью.\n\nОкей, но у нас есть классы в Реакте как способ **инкапсуляции** компонента и нам нужно с этим что-то делать. Придётся изучать (хотя совсем недавно вышел [@reactions/component](https://github.com/reactions/component) и слава Райану, можно уйти от классов).\n\n`constructor` в нашем примере это по сути такой же лайфсайкл-метод, но не Реакта, а просто класса. В него аргументом приходит то, что вы передали при **инициализации** класса через `new MySuperClass(...)`. При инициализации создаётся **экземпляр** класса. Тяжко? Понимаю.\n\nСледующее незнакомое нам это `this`. `this` это специальный объект, в котором есть данные, которые принадлежат этому **скоупу**. Пример с функциями:\n\n```js\n(function parent() {\n  this.x = 1;\n  console.log(this.x); // 1\n\n  (function child() {\n    console.log(this.x); // 1\n    this.x = 2;\n    console.log(this.x); // 2\n  })();\n\n  console.log(this.x);\n})();\n```\n\n> Функции обёрнуты в `()()` чтобы их сразу же вызвать — вторыми скобками мы вызываем как будто `myFunc()`, но сначала нужно обернуть в скобки, чтобы не было `function {}()` — интерпретатор не поймёт что мы от него хотим и откуда взялись `()`.\n\n---\n\nНо почему у вложенной функции на первом консольлоге всё равно доступен `this` родительской?\n\nЭто **кложа** (closure, на русском обычно говорят \"замыкание\") — функция со всеми внешними данными, что ей доступны. Второй пример на кложу:\n\n```js\nconst x = 1;\n\n(function() {\n  const y = 2;\n\n  console.log(x); // 1\n\n  (function() {\n    const z = 3;\n\n    console.log(y); // 2\n    console.log(z); // 3\n  })();\n\n  console.log(z); // ReferenceError: z is not defined\n})();\n\nconsole.log(y); // ReferenceError: y is not defined\nconsole.log(z); // ReferenceError: z is not defined\n```\n\nПочему `y` и `z` недоступны? Потому что это внутренние константы тех двух функций.\n\n---\n\nОкей, разобрались с кложами и `this`, разве что добавлю, что у каждого **экземпляра** класса свой `this`:\n\n```js\nconst square = new Rectangle(10, 10);\nconst rectangle = new Rectangle(100, 203);\n\nconsole.log(square); // Rectangle { width: 10, height: 10 }\nconsole.log(rectangle); // Rectangle { width: 100, height: 203 }\n```\n\n### Наследование\n\nВторое, что нас интересует в классах — наследование. Наследование делается через синтаксис `class extends X {}` и наследование означает, что методы и свойства класса X перейдут в новый. Для этого нужно в своём классе вызвать [`super()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super) в конструкторе.\n\n```js\nclass X {\n  calcTotal() {\n    return this.height * this.width;\n  }\n}\n\nclass Rectangle extends X {\n  constructor(height, width) {\n    super(height, width);\n    this.height = height;\n    this.width = width;\n  }\n}\n\nconst square = new Rectangle(10, 10);\nconst rectangle = new Rectangle(100, 203);\n\nconsole.log(square.calcTotal()); // 100\nconsole.log(rectangle.calcTotal()); // 20300\n```\n\nОкей, вроде всё более-менее понятно, хоть и бесполезно, давайте возвращаться в лоно Реакта и писать нормально.\n\n## Классовые компоненты\n\nВсё это погружение в классы нужно было, чтобы познакомить вас с [классовыми компонентами](https://reactjs.org/docs/components-and-props.html#functional-and-class-components).\n\n```jsx\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n\nclass WelcomeClassed extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n```\n\nКак видите, разница в случае рендера не особо велика: ну подумаешь, обернули в класс и прописали метод `render()`, а пропы из аргументов переехали в `this`.\n\nКстати, вы же знаете, что каждый раз `this` будет разным для каждого вызова одного и того же компонента? Теперь знаете.\n\n```jsx\nclass Img extends React.Component {\n  render() {\n    console.log(this.props);\n\n    return <img src={this.props.src} />;\n  }\n}\n\n<Img src=\"https://i.imgur.com/wycmlAg.jpg\" /> // { src: \"https://i.imgur.com/wycmlAg.jpg\" }\n<Img src=\"https://i.imgur.com/82kaBeI.jpg\" /> // { src: \"https://i.imgur.com/82kaBeI.jpg\" }\n```\n\nОкей, мы отнаследовались от `React.Component`, что нам это даёт? Правильно, работу со стейтами и лайфсайклы-методы!\n\n### Стейты\n\nНачальный стейт компонента объявляется как поле или в конструкторе\n\n```js\nclass extends React.Component {\n  // стейт объявляется как поле\n  state = {}\n\n  // либо в конструкторе, но зачем\n  constructor(props) {\n    super(props);\n\n    this.state = {};\n  }\n}\n```\n\nСтейт обновляется через метод `this.setState()`, в который нужно передать новый стейт. Что? Где он, если мы его не объявили? Явное лучше неявного? Добро пожаловать в ООП, где так не думают!\n\n`this.setState()` нам подарен экстендом `React.Component`. Где его можно вызывать? Везде, кроме рендера\n\n### Лайфсайклы\n\nЛайфсайклы это методы вашего класса и они вызываются самим Реактом.\n\n```jsx\n// src/Movies/List.js\nimport React from 'react';\nimport Card from './Card';\nimport { Loading } from '../ui';\n\nclass Movies extends React.Component {\n  // начальный стейт\n  state = {\n    list: [],\n    isLoading: false\n  }\n\n  // почему didMount вместо willMount?\n  // https://daveceddia.com/where-fetch-data-componentwillmount-vs-componentdidmount/\n  componentDidMount() {\n    // поставим что мы отправили запрос\n    this.setState({ isLoading: true });\n\n    // отправляем запрос к АПИ\n    const response = fetch(\"/api/v1/movies\");\n\n    // ставим в стейт ответ\n    this.setState({ list: response.list });\n  }\n\n  render() {\n    // render() вызывается на каждом обновлении стейта или пропов\n    // поэтому Реакт сам решит что ему показать\n    // мы же описываем интерфейс от стейта, состояния компонента\n    return (\n      <section>\n        {this.state.isLoading && <Loading>...</Loading>}\n        {this.state.list.map(movie => {\n          return <Card data={movie} />\n        });\n      </section>\n    )\n  }\n}\n```\n\nНужно ли вызывать класс через `new Movies()`? Нет, используйте как обычный компонент через Джсх или `React.createElement()`, а работу с функциональными или классовыми компонентами Реакт возьмёт на себя.\n\n## Итог\n\nУрок получился сложным — это камень в огород ООП. Когда мы вернулись к Реакту, стало всё намного лучше и понятнее.\n\nСегодня мы разобрались с:\n\n* лайфсайклами,\n* Error Boundaries,\n* классами,\n* `this`,\n* кложами (они же замыкания),\n* наследованиями,\n* работой со всем этим в Реакте\n\nГлавный вывод: в большинстве случаев нужно использовать функциональные компоненты, а когда нужны стейты или лайфсайкл-методы — классы. Либо смотреть в сторону [reactions/component](https://github.com/reactions/component).\n\nКстати, мы в уроке не разобрались с вопросом а когда всё же нужны стейты или лайфсайклы.\n\n### Когда нужны стейты\n\nКогда у компонента должно быть **своё** состояние. Старайтесь не размазывать по двадцати компонентам то, что можно хранить в одном и [спускать пропами](https://medium.com/@jmuse/d86394da2b50), но и свалку не устраивайте.\n\n### Когда нужны лайфсайклы\n\nОбычно нужны три лайфсайкла: `componentDidMount()`, `componentWillReceiveProps(nextProps)` и `componentDidCatch(error, info)`.\n\n* `componentDidMount()` — при загрузке компонента (например, сменили страницу в роутере),\n* `componentWillReceiveProps(nextProps)` — когда изменились данные (например, сменили страницу в роутере, компонент остался тем же, а данные новые),\n* `componentDidCatch(error, info)` — когда поймали ошибку.\n",
      "isPublic": true,
      "id": "mcAOpwEyPI",
      "stageId": "rHAh7OXEFL"
    },
    {
      "stage": 2,
      "title": "Реакт — не фреймворк, но как построить проект?",
      "subTitle": "Архитектура и основные модули из экосистемы Реакта",
      "markdown": "Чем в сознании разработчика библиотека отличается от фреймворка? Библиотека решает конкретную задачу, фреймворк даёт экосистему и диктует архитектуру.\n\nКогда впервые знакомишься с Реактом, то после всяких Ангуларов не понимаешь, как же с ним работать: это же библиотека для вёрстки, почему я должен её использовать? У меня всё хорошо, есть `@angular/common/http`, `@angular/universal`, `@angular/router` и прочее, а тут мне нужно из говна и палок слепить проект, не хочу этим заниматься!\n\nТак-то оно правда, но вы пользуетесь Реактом в 2018 году, а не в 2014, когда ещё ничего не было, так что сегодня мы рассмотрим основные библиотеки, которые можно использовать с Реактом.\n\n## Библиотеки\n\n### Стилизация\n\nКак вы понимаете, [Styled Components](https://styled-components.com). Эту идеальную библиотеку пока никто не переплюнет.\n\n### Роутинг\n\nЕго мы тоже проходили, это [Реакт-роутер](https://reacttraining.com/react-router).\n\n### ХТТП-запросы\n\nСравнительно [новый](https://caniuse.com/#feat=fetch) браузерный АПИ для запросов.\n\nЕсли нужна поддержка старых браузеров, используют полифилл [github/fetch](https://github.github.io/fetch/).\n\n_(полифилл это библиотека, которая предоставляет новую функциональность через старые технологии — например, в этом случае `fetch` работает на XMLHttpRequest)_\n\n### Формы\n\nВ интерфейсах часто бывают формы: инпуты, селекты и прочие поля ввода, а у форм ведь должна быть валидация данных и прочие возможности.\n\n[Formik](https://github.com/jaredpalmer/formik) либо [react-final-form](https://github.com/final-form/react-final-form).\n\n### Хранение данных\n\nСтейт компонента. Да, я не шучу, в 99.99999999% случаев [используйте](https://medium.com/@jmuse/d86394da2b50) локальный стейт компонента или его родителей.\n\nПочему часто советуют Редакс или Мобкс? Потому что в 2015 Редакс был очень модным и все старались его воткнуть себе в проект, а потом оказалось, что он на пустом месте усложняет проект. Сам Даня Абрамов говорит, что скорее всего [вам не нужен Редакс](https://medium.com/@dan_abramov/be46360cf367).\n\n### Модальные окна\n\nЛибо [react-portal](https://github.com/tajo/react-portal), либо [ReactDOM.createPortal()](https://reactjs.org/docs/portals.html).\n\n### Бутстрап или его замена\n\nЧасто советуют [Ant Design](https://ant.design/), но лично я не пользовался: у меня всегда был свой дизайн.\n\n### Работа с `<head />`\n\nТайтлы, описания, [опенграф](http://ogp.me/)-теги обновляются через [react-helmet](https://github.com/nfl/react-helmet).\n\n### Даты\n\n[date-fns](http://date-fns.org) и [react-day-picker](http://react-day-picker.js.org/).\n\nmoment.js слишком жирный и придерживается мутабельности — это неудобно.\n\n### Селекты и автодополнения\n\nРаньше был react-select, но он вообще не поддерживается автором.\n\nСейчас есть [downshift](https://github.com/paypal/downshift), но это достаточно низкоуровневая библиотека, поверх которой можно строить свои компоненты — посмотрите [примеры](https://github.com/paypal/downshift#examples) в документации.\n\n### Карты\n\nЗависит от сервиса, который вы используете: например, [`google-map-react`](https://github.com/istarkov/google-map-react) или [`react-yandex-maps`](https://www.npmjs.com/package/react-yandex-maps).\n\n### Графики\n\nОбычно все графики работают поверх [d3.js](https://d3js.org/) — это самая мощная библиотека для работы с ними, посмотрите на [эти демки](https://bl.ocks.org/), которые собирает автор.\n\n[vx](https://vx-demo.now.sh) — библиотека, которая дружит d3 и Реакт.\n\n---\n\nОбычно хватает поиска в Гугле «react x», а после остаётся только выбрать.\n\nВот несколько правил:\n\n* **версия желательно не должна быть 0.х**: по Семверу всё [может](http://semver.org/) сломаться,\n* **понятные описания релизов**: если нет файла `CHANGELOG.md` или вкладка Releases на Гитхабе пустует, то вам сложно будет обновляться,\n* **должны быть ишью и пулл-реквесты**: библиотекой должен пользоваться кто-то кроме её автора.\n\n### А как же Вебпак и Бейбель\n\nУ вас есть CRA, который скрыл настройку Вебпака и Бейбеля под собой. Можете выдохнуть.\n\n## Архитектура проекта\n\nЕдем дальше. Частый вопрос: а как организовывать проект?\n\n### Бизнес-логика превыше всего\n\nОрганизация проекта строится по **бизнес-логике**: нет нужды делать кучу директорий `src/components/Properties`, `src/containers/Properties`, `src/actions/Properties`, `src/api/Properties`, если можно всё положить в `src/Properties/{actions,api}`.\n\nОбъединять по доменам проще, чем бегать по 10 директориям, вы же в один момент времени работаете только с одной сущностью?\n\nНапример, вам нужно сделать авторизацию, `Auth`: две страницы (логин, регистрация), несколько компонентов, запросы к серверу. Когда вы её делаете, вы же не отвлекаетесь на другие компоненты или файлы? Вы работаете конкретно над авторизацией.\n\nДумайте продуктом, а не ненужными абстракциями типа компонентов или контейнеров. Люди в вашем продукте пользуются конкретной функциональностью, а не экшенами, редьюсерами или контейнерами.\n\n### Избавьтесь от components\n\nНет, я серьёзно: даже после предыдущего пункта люди часто оставляют директорию `components`. У вас всё приложение построено на компонентах, зачем директорию отдельно создавать?\n\nЕсли хотите какой-нибудь хедер или футер переиспользовать на разных страницах, то положите в корень `src`, а не в `src/components` или `src/shared`.\n\nДля интерфейсных вещей типа форм, кнопок и прочего обычно используют `src/ui`.\n\n### Не создавайте директории ради одного файла\n\nЧасто вижу `src/Header`, в котором лежит сиротливый `index.js`. Зачем? На будущее? Преждевременные оптимизации — корень всех бед.\n\nПоложите в `src/Header.js`.\n\n### Смешивать стили, рендер и логику можно\n\nЭто же компонентный подход, ничего страшного если в одном файле будут СК, \"главный\" Реакт-компонент с запросами или обработчиками событий.\n\nЕсли стилей много, то ваш выбор `styled.js` с экспортами рядом с файлом.\n\n### Переиспользуйте компоненты\n\nЕщё один частый вопрос: а как мелко дробить компоненты?\n\nДробите до переиспользуемости. Если у вас есть два огромных блока, в которых повторяется только кнопка, то вынесите кнопку в отдельный компонент, а всё остальное оставьте как есть: смысл дробить меньше?\n\nНо если работать неудобно с компонентом — то дробите тоже.\n\n## Итог\n\nСегодняшним уроком я хотел вам показать, что Реакт это устоявшаяся экосистема, где либо используются стандарты (фетч), либо есть давно устоявшиеся библиотеки, заточенные чисто под Реакт.\n\n---\n\nПример неплохой архитектуры? Например, моя неплоха, хоть и неидеальна.\n\n```\nsrc\n├── About.js\n├── Announces\n│   ├── CourseReactAnnounce.js\n│   └── index.js\n├── App.js\n├── Buy\n│   ├── Closed.js\n│   ├── Medium.svg\n│   ├── Old.js\n│   ├── Telegram.svg\n│   ├── VK.svg\n│   ├── YouTube.svg\n│   ├── index.js\n│   └── tinkoff.js\n├── Companies\n│   ├── everpoint.js\n│   └── index.js\n├── Courses\n│   ├── Lessons\n│   │   ├── Header.js\n│   │   ├── Lesson.js\n│   │   ├── ReactMarkdown.js\n│   │   ├── Stage.js\n│   │   ├── external-link.svg\n│   │   └── styled.js\n│   ├── React\n│   │   ├── About.js\n│   │   ├── Antihire.js\n│   │   ├── Buy.js\n│   │   ├── Changes\n│   │   │   ├── clocks.svg\n│   │   │   └── index.js\n│   │   ├── Footer\n│   │   │   ├── index.js\n│   │   │   ├── md.svg\n│   │   │   ├── tg.svg\n│   │   │   ├── vk.svg\n│   │   │   └── yt.svg\n│   │   ├── Header\n│   │   │   ├── atom.png\n│   │   │   └── index.js\n│   │   ├── History\n│   │   │   ├── index.js\n│   │   │   └── max.svg\n│   │   ├── Kursach\n│   │   │   ├── index.js\n│   │   │   └── kursach.svg\n│   │   ├── LandingUI.js\n│   │   ├── Project\n│   │   │   ├── Aviasales\n│   │   │   │   ├── aviasales.svg\n│   │   │   │   └── index.js\n│   │   │   ├── Dates.js\n│   │   │   ├── Format\n│   │   │   │   ├── format.svg\n│   │   │   │   ├── assistant.svg\n│   │   │   │   ├── code_review.svg\n│   │   │   │   └── index.js\n│   │   │   └── index.js\n│   │   ├── Quote.js\n│   │   ├── Reviews\n│   │   │   ├── Review.js\n│   │   │   └── index.js\n│   │   ├── SoftSkills\n│   │   │   ├── index.js\n│   │   │   ├── softskills_0.jpg\n│   │   │   ├── softskills_0_mobile.png\n│   │   │   ├── softskills_1.jpg\n│   │   │   ├── softskills_1_mobile.png\n│   │   │   ├── softskills_2.jpg\n│   │   │   ├── softskills_2_mobile.png\n│   │   │   ├── softskills_small_0.jpg\n│   │   │   ├── softskills_small_0_mobile.png\n│   │   │   ├── softskills_small_1.jpg\n│   │   │   ├── softskills_small_1_mobile.png\n│   │   │   ├── softskills_small_2.jpg\n│   │   │   └── softskills_small_2_mobile.png\n│   │   └── index.js\n│   ├── Verstka\n│   │   ├── Landing\n│   │   │   ├── About.js\n│   │   │   ├── Buy.js\n│   │   │   ├── Chat.js\n│   │   │   ├── Course.js\n│   │   │   ├── Feedback\n│   │   │   │   ├── bot.png\n│   │   │   │   ├── chats.png\n│   │   │   │   ├── code-review-feedback.png\n│   │   │   │   └── index.js\n│   │   │   ├── Format\n│   │   │   │   ├── index.js\n│   │   │   │   └── uberEats@2x.png\n│   │   │   ├── Kursach\n│   │   │   │   ├── cursach@2x.png\n│   │   │   │   └── index.js\n│   │   │   ├── Questions\n│   │   │   │   ├── Question.js\n│   │   │   │   ├── data.js\n│   │   │   │   └── index.js\n│   │   │   ├── Reviews\n│   │   │   │   ├── index.js\n│   │   │   │   └── reviews@2x.png\n│   │   │   └── index.js\n│   │   ├── Study\n│   │   │   ├── Footer.js\n│   │   │   ├── link.svg\n│   │   │   ├── Lessons.js\n│   │   │   ├── codeRenderer.js\n│   │   │   └── styles.js\n│   │   └── index.js\n│   └── index.js\n├── Footer\n│   ├── index.js\n│   ├── md.svg\n│   ├── tg.svg\n│   ├── vk.svg\n│   └── yt.svg\n├── Frontend\n│   ├── About.js\n│   ├── Buy.js\n│   ├── Feedback\n│   │   ├── Reviews@2x.png\n│   │   └── index.js\n│   ├── Format.js\n│   ├── Kursach\n│   │   ├── index.js\n│   │   └── screenshot.png\n│   ├── Landing.js\n│   ├── LandingFeb\n│   │   ├── Program.js\n│   │   ├── Steps.js\n│   │   ├── aviasales.png\n│   │   └── index.js\n│   ├── NewYearBuy.js\n│   ├── Payed.js\n│   ├── Plan.js\n│   ├── Premium.js\n│   ├── Program.js\n│   ├── Questions\n│   │   ├── Question.js\n│   │   ├── data.js\n│   │   └── index.js\n│   ├── Result.js\n│   ├── Reviews\n│   │   ├── Navigation.js\n│   │   ├── Review.js\n│   │   ├── data.js\n│   │   └── index.js\n│   ├── Steps.js\n│   ├── Study\n│   │   ├── Footer.js\n│   │   ├── Lessons.js\n│   │   └── index.js\n│   ├── data.js\n│   └── index.js\n├── Header.js\n├── Helmet.js\n├── Home\n│   ├── Courses.js\n│   ├── YouTube\n│   │   ├── index.js\n│   │   └── youtube@2x.png\n│   ├── data.js\n│   └── index.js\n├── Navigation.js\n├── Payment\n│   ├── Gift\n│   │   ├── Telegram.svg\n│   │   ├── bg@2x.png\n│   │   └── index.js\n│   ├── copy.svg\n│   ├── fb.svg\n│   ├── index.js\n│   ├── ok.svg\n│   ├── tw.svg\n│   └── vk.svg\n├── ReactRemarkable\n│   ├── components.js\n│   ├── index.js\n│   └── toc\n│       ├── index.js\n│       └── utils.js\n├── ScrollToTop.js\n├── analytics.js\n├── api.js\n├── fonts\n│   ├── GraphikLCG\n│   │   ├── GraphikLCG-Black.eot\n│   │   ├── GraphikLCG-Black.ttf\n│   │   ├── GraphikLCG-Black.woff\n│   │   ├── GraphikLCG-Bold.eot\n│   │   ├── GraphikLCG-Bold.ttf\n│   │   ├── GraphikLCG-Bold.woff\n│   │   ├── GraphikLCG-Medium.eot\n│   │   ├── GraphikLCG-Medium.ttf\n│   │   ├── GraphikLCG-Medium.woff\n│   │   ├── GraphikLCG-Regular.eot\n│   │   ├── GraphikLCG-Regular.ttf\n│   │   ├── GraphikLCG-Regular.woff\n│   │   ├── GraphikLCG-Semibold.eot\n│   │   ├── GraphikLCG-Semibold.ttf\n│   │   └── GraphikLCG-Semibold.woff\n│   └── KazimirText\n│       ├── KazimirText-Roman.eot\n│       ├── KazimirText-Roman.ttf\n│       └── KazimirText-Roman.woff\n├── index.css\n├── index.js\n├── registerServiceWorker.js\n└── ui\n    ├── Aside.js\n    ├── Button.js\n    ├── Code.js\n    ├── H1.js\n    ├── H2.js\n    ├── H3.js\n    ├── H4.js\n    ├── HeroUnit.js\n    ├── Link.js\n    ├── P.js\n    ├── Wrapper.js\n    └── index.js\n```\n",
      "isPublic": true,
      "id": "uUcxgnAvbj",
      "stageId": "rHAh7OXEFL"
    },
    {
      "stage": 2,
      "title": "Работа с Рест АПИ через fetch, а также про ХТТП от и до",
      "subTitle": "Как брать данные, где брать данные и что такое асинхронное программирование",
      "markdown": "# Про ХТТП\n\n<iframe width=\"100%\" height=\"541\" src=\"https://www.youtube.com/embed/WzjDqrS22Jg\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe>\n\nЕсли вы читали [второй урок](https://erodionov.ru/courses/verstka/FhTKluFzm7/nHdviS9Jil) курса по вёрстке, то вы помните, что весь интернет работает на ХТТП, связке \"клиенты-сервер\" и, конечно, запросах с ответами.\n\n## ХТТП\n\nХТТП это протокол передачи данных: мы отправляем к серверу запрос и получаем ответ.\n\nМы — это клиент, а клиентом может быть хоть `wget` или `curl` из Терминала, хоть браузер. Хоть микроволновка на Андроиде.\n\nКак выглядит запрос? У него есть адрес и метод: `GET`, `POST`, `PUT`, `DELETE`, `PATCH`, `OPTIONS` — вы делаете запрос на адрес и указываете метод.\n\nЗачем это нужно? У каждого **ресурса** может быть поддержка нескольких методов: например, на `POST /users` создаётся новый пользователь, а на `GET` — запрашивается список.\n\n- `GET` — запросить данные,\n- `POST` — создать новую **сущность**,\n- `PUT` — обновить существующую,\n- `DELETE` — удалить её,\n- `PATCH` — частично обновить,\n- `OPTIONS` — доступные опции у ресурса\n\nПримеры?\n\n- `GET /users` — запросить список пользователей,\n- `POST /users` — создать пользователя,\n- `PUT /users/evgenyrodionov` — обновить пользователя `evgenyrodionov`,\n- `PATCH /users/evgenyrodionov` — частично обновить пользователя `evgenyrodionov`,\n- `OPTIONS /users` — запросить опции, доступные на ресурсе (допустим, параметры фильтрации).\n\nЕсть много вопросов, давайте на них отвечу. Начнём снизу.\n\n### Как передавать параметры\n\nДля этого есть кверипарамс (query params) — это те параметры, которые указываются у адреса, например, `GET /users?state=active&offset=20&courseId=react`\n\nКверипарамс это всего лишь строка в формате `key=value` и объединением через `&`.\n\nВ джсе легче всего работать через пакет [`qs`](https://npm.im/qs) — он преобразовывает кверипарамс в объект и обратно.\n\n### В чём отличие PATCH от PUT\n\nВ `PUT` уходит новый объект, а в `PATCH` — список изменений.\n\n### А как это передавать\n\nДля этого есть **тело запроса**, обычно это Джаваскрипт объект (или JSON).\n\n```\nPOST /users\n\n{\n  \"username\": \"evgenyrodionov\",\n  \"email\": \"kurs@erodionov.ru\",\n  \"age\": 24\n}\n```\n\nДля Джсона используется контент-тайп `application/json`, но бывают ещё `multipart/form-data` (раньше для форм, сейчас в основном для файлов). Что это такое? Это [майм-типы](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types).\n\n### А как их указывать\n\nДля этого используется заголовок `content-type: application/json`.\n\n### Заголовок?\n\nДа, у каждого запроса есть [**заголовки**](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers) — это служебная информация для сервера, которую не стоит пихать в тело запроса.\n\nВот основные:\n\n- `content-type` — тип тела,\n- `accept` — в чём обрабатывается ответ (тоже майм-тип),\n- `cookie` — [куки](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies),\n- `authorization` — авторизационные данные (например, логин и зашифрованный пароль)\n\nОбычно разработчик работает с этими заголовками.\n\n### А есть заголовки ответа?\n\nДа.\n\n### Например?\n\nОдин из самых основных это `status`.\n\nСтатус это [**код** ответа](https://httpstatuses.com/), по которому можно определить насколько успешно прошёл запрос. Кодов много, но вот основные:\n\n#### 2xx\n\nЭто успешные коды ответа.\n\n- [200 OK](https://httpstatuses.com/200) — сервер обработал запрос,\n- [201 Created](https://httpstatuses.com/201) — создан новый ресурс,\n- [204 No Content](https://httpstatuses.com/204) — сервер обработал запрос, но ему нечего прислать в теле.\n\n#### 3xx\n\nОтвечают за редиректы, нужен заголовок `location` с новым адресом.\n\n- [301 Moved Permanently](https://httpstatuses.com/301) — ресурс навсегда переехал,\n- [302 Found](https://httpstatuses.com/302) — ресурс временно находится по другому адресу.\n\n#### 4xx\n\nЗапрос был отправлен с ошибкой на стороне клиента (например, неправильно поле заполнено).\n\n- [400 Bad Request](https://httpstatuses.com/400) — общая ошибка и не очень понятная,\n- [401 Unauthorized](https://httpstatuses.com/401) — человек не авторизован,\n- [403 Forbidden](https://httpstatuses.com/403) — нет доступа,\n- [404 Not Found](https://httpstatuses.com/404) — ресурс или сущность не найдены.\n\n#### 5xx\n\nПроблемы на стороне сервера.\n\n- [500 Internal Server Error](https://httpstatuses.com/500) — такая же общая и слабо понятная ошибка, как 400,\n- [501 Not Implemented](https://httpstatuses.com/501) — ресурс не реализован,\n- [502 Bad Gateway](https://httpstatuses.com/502) — плохой ответ,\n- [503 Service Unavailable](https://httpstatuses.com/503) — сервис временно недоступен, полезно отправить заголовок [`retry-after`](https://tools.ietf.org/html/rfc7231#section-7.1.3) с времнем в секундах,\n- [504 Gateway Timeout](https://httpstatuses.com/504) — ответ не был получен вовремя.\n\n---\n\nСуммируем.\n\nВеб работает на протоколе ХТТП по системе \"клиент-сервер\": клиент посылает запрос на адрес, сервер присылает ответ.\n\nКлиент может передать заголовки и тело, а сервер может прислать заголовки и тело.\n\nКлиент это любой инструмент, который работает с ХТТП — хоть другой сервер, хоть утилита в Терминале, хоть бот в Телеграме.\n\nНо как со всем этим работать во фронтэнде?\n\n## Рест АПИ\n\nВы часто, наверное, слышите про Рест АПИ — мол, наш АПИ он РЕСТФул, мол, полностью по стандартам.\n\nИрония в том, что любой АПИ, построенный на ХТТП, будет рестовым — в этом и смысл ХТТП. Посмотрите на это определение из Википедии:\n\n> REpresentational State Transfer (_REST_), or RESTful, web services provide interoperability between computer systems on the Internet\n\nВ мире нет единого стандарта построения АПИ бэкэнда — каждый дрочит, как он хочет. Нет, серьёзно, посмотрите на эту тьму гайдлайнов: [HackerNoon](https://hackernoon.com/restful-api-designing-guidelines-the-best-practices-60e1d954e7c9), [studioarmix](https://medium.com/studioarmix/learn-restful-api-design-ideals-c5ec915a430f), [Некий Филип](https://blog.philipphauer.de/restful-api-design-best-practices/), [Майкрософт](https://github.com/Microsoft/api-guidelines), [Гугл](https://cloud.google.com/apis/design/), [RestCase](http://blog.restcase.com/5-basic-rest-api-design-guidelines/). Тысячи их!\n\nМне больше всего нравятся [архитектура и документация](https://stripe.com/docs/api) у Страйпа — это эквайринг для приёма платежей. Почитайте как-нибудь.\n\n## Асинхронность, лайфсайклы и фетч\n\n<iframe width=\"100%\" height=\"541\" src=\"https://www.youtube.com/embed/ATYQtAjOgHE\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe>\n\n### Фетч\n\nРаньше был [XMLHttpRequest](https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest) — браузерный АПИ для запросов. Неудобный аж жуть.\n\nПоэтому когда появился Джквери с его функцией `$.ajax()`, люди выдохнули: наконец-то удобный способ для работы с ХТТП.\n\nЧестно говоря, это было одним из поворотных событий, которое привело нас к так называемому Вебу 2.0: интерактивному и без перезагрузок страниц. Веб стал больше похож на приложения, чем на сайты.\n\nЗатем этот подход забрали себе библиотеки [axios](https://github.com/axios/axios) и [superagent](https://github.com/visionmedia/superagent).\n\nНу а позже появился новый браузерный АПИ [fetch](https://developer.mozilla.org/en/docs/Web/API/Fetch_API) — сейчас его многие и используют. Если нужна поддержка старых браузеров — берут полифилл [github/fetch](https://github.github.io/fetch/) от Гитхаба.\n\nСобственно, Фетч. Фетч это АПИ браузера, которое работает с ХТТП: вы делаете запрос на адрес и обрабатываете ответ.\n\nЧисто технически, это просто одна функция `fetch()`, которая построена на промисах. То есть на чём? Об этом позже.\n\nВ Фетч вы передаёте адрес и опции: от заголовков до тела запроса, вот пример —\n\n```js\nconst data = {\n  username: \"evgenyrodionov\",\n  email: \"kurs@erodionov.ru\",\n  age: 24\n};\n\nfetch(\"/api/v1/users\", {\n  method: \"POST\", // метод\n  body: JSON.stringify(data), // тело\n  // заголовки\n  headers: {\n    \"Content-Type\": \"application/json\"\n  },\n  // работа с куки\n  credentials: \"same-origin\"\n})\n  .then(\n    function(response) {\n      // https://github.github.io/fetch/#Response\n      console.log(response.status); //=> number 100–599\n      console.log(response.statusText); //=> String\n      console.log(response.headers); //=> Headers\n      console.log(response.url); //=> String\n\n      return response.json();\n    },\n    function(error) {\n      error.message; //=> String\n    }\n  )\n  .then(function(responseAsJson) {\n    console.log(responseAsJson);\n    //  {\n    //    \"id\": 1, // новое поле, потому что пользователь успешно создан\n    //    \"username\": \"evgenyrodionov\",\n    //    \"email\": \"kurs@erodionov.ru\",\n    //    \"age\": 24\n    //  }\n  });\n```\n\nОкей, запрос понятен, вроде даже ответ как-то обрабатываем в функции, которую передаём в `.then`. Кстати, а что за `.then`?\n\n#### Асинхронное программирование\n\nНа этом моменте мы узнаем интересный аспект: бывают синхронное и асинхронное программирование. К плаванью отношения не имеют.\n\nСинхронное программирование это когда интерпретатор код выполняет строчка за строчкой:\n\n```js\nconst x = 1;\n\nconsole.log(x); // 1\n```\n\nВ асинхронном программировании мы не знаем, когда выполнится наша функция: то ли сразу же, то ли через 10 мс, то ли через 50 секунд, то ли через 20 минут. И как быть? Как с этим работать?\n\nСуществуют три способа.\n\n##### Коллбэки\n\nКоллбэки (callbacks) это простая функция, которая вызывается, когда выполнится функция, которую вы вызвали.\n\nВы знали, что `setState()` [асинхронный](https://reactjs.org/docs/react-component.html#setstate)? Если вы попробуете обратиться к стейту на следующей строчке после вызова `setState()`, вы можете удивиться, когда увидите старые данные.\n\n```js\nimport React from \"react\";\n\nclass Counter extends React.Component {\n  state = {\n    counter: 0\n  };\n\n  handleClick = () => {\n    this.setState({ counter: this.state.counter + 1 });\n    console.log(this.state); // 0\n  };\n\n  render() {\n    return (\n      <React.Fragment>\n        <pre>{JSON.stringify(this.state, null, 2)}</pre>\n        <button onClick={this.handleClick}>+</button>\n      </React.Fragment>\n    );\n  }\n}\n```\n\n<iframe src=\"https://codesandbox.io/embed/0mqo1ol5yl\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\nВозможно, вы и не увидите этого: смысл ведь не в том, что запрос выполняется с задержкой, а в том, что неизвестно время получения результата.\n\nПочему `setState` асинхронный? Потому что бывает, что Реакт накапливает вызовы и потом разом обновляет стейт: так производительнее.\n\nКак с этим работать? Обращайтесь к стейту в коллбеке.\n\n```js\nthis.setState({ counter: this.state.counter + 1 }, function() {\n  console.log(this.state); // 1\n});\n```\n\nКоллбек это функция, которая передаётся аргументом и вызывается, когда код отработан. Пример:\n\n```js\nfunction multiplyNumber(number, cb) {\n  const multiplied = number * number;\n\n  cb(multiplied);\n}\n\nconsole.log(multiplyNumber(2)); // undefined, потому что нет return в функции\n\nmultiplyNumber(2, function(result) {\n  console.log(result); // 4\n});\n```\n\n##### Промисы\n\nПромисы (Promises) это обещания. Чисто технически, это те же коллбеки, но на стероидах: вместо аргумента мы используем методы `.then()` и `.catch()` у функции-промиса. Фетч работает на промисах. В методы мы передаём функцию.\n\n```js\nfetch(url, params)\n  .then(function(response) {\n    console.log(response);\n  })\n  .catch(function(error) {\n    console.log(error);\n  });\n```\n\n##### Асинк-эвейт\n\nВ 2017 году в Экмаскрипт (стандарт, на котором работает Джаваскрипт) привезли новую фичу: `async-await` — способ писать в синхронном стиле асинхронный код.\n\nАсинк-эвейты работают вместо промисов в том числе.\n\n```js\nconst response = await fetch(url, params);\n\nconsole.log(response);\n```\n\nА как работать с ошибками? Через конструкцию `try..catch`:\n\n```js\ntry {\n  const response = await fetch(url, params);\n\n  console.log(response);\n} catch (error) {\n  console.log(error);\n}\n```\n\nВсегда обрабатывайте ошибки! Даже если знаете, что придут \"чистые\" данные: я так понадеялся на Телеграм и однажды свалил сайт на полчаса, потому что Телеграм стал присылать ошибку, которую я не обрабатывал — из-за этого падал весь бэкэнд.\n\nКогда он перезапускался, то заново пытался выполнить и терпел неудачу, снова падая. С тех пор у меня весь код в `try..catch`.\n\n---\n\nРезюмируя: для ХТТП-запросов мы используем Фетч, который работает асинхронно.\n\nВ асинхронном программировании мы не знаем, когда придёт результат, поэтому пишем функцию, которая вызовется, когда он всё-таки придёт.\n\nДля асинхронного программирования есть три подхода в Джс: коллбэки, промисы и асинк-эвейт. Чтобы не было проблем и не бегать с горящей жопой, всегда нужно ловить ошибки и их обрабатывать: либо для себя выводить, либо использовать сервис тип Сентри или Багснега, либо показать ошибку пользователю.\n\nКстати, асинхронное программирование нужно, чтобы не блокировать основной **поток** исполнения кода: представьте, как бы вас бесил интерфейс, если бы он замерзал (даже скроллить нельзя!) пока не получил ответ или не обновил стейт. Ужасно же.\n\n## Итог\n\nСегодня мы прошлись по устройству ХТТП, узнали про асинхронное программирование, коллбэки, промисы и асинк-эвейты и Фетч, который работает на последних двух подходах.\n\nИ помните: всегда обрабатывайте ошибки. Это чертовски важно, хоть и рутинно сложно. Лучше пользователь увидит непонятное \"произошла ошибка\", чем не поймёт что произошло. А ещё лучше, если он узнает на чьей она стороне и что он может с этим сделать.\n",
      "isPublic": true,
      "id": "bhWxD2rQV1",
      "stageId": "rHAh7OXEFL"
    },
    {
      "stage": 2,
      "title": "Как понять Редакс без Редакса?",
      "subTitle": "Редакс умещается в 100 строчек и его можно воссоздать на обычном `setState`. Как?",
      "markdown": "Что такое [Редакс](https://redux.js.org/)? Это библиотека для работы с состоянием, стейт-менеджер. В чём её отличие от `setState`? В немного другом АПИ и библиотеке [react-redux](https://npm.im/react-redux), благодаря которой можно цепляться к стейту в любом компоненте.\n\nОсновная идея Редакса в глобальном стейте: у вас есть один источник данных, который вы цепляете к компоненту.\n\nК сожалению, часто люди возводят это в абсолют и **все** данные засовывают в стейт Редакса. Получается сложно и неудобно, появляются библиотеки типа [redux-saga](https://github.com/redux-saga/redux-saga) чтобы справиться с этим добром, развиваются мифы о сложности Редакса. Даня Абрамов, автор, настолько в ахуе, что даже написал статью [You Might Not Need Redux](https://medium.com/@dan_abramov/be46360cf367).\n\n**Главное правило** работы с Редаксом: глобальный стейт нужен только когда нужно расшарить данные между компонентами, у которых родитель находится слишком далеко.\n\nДавайте рассмотрим на сайте jqestate.ru.\n\nДля начала зайдём в загородную недвижимость, загрузим список объектов через АПИ и сохраним его в стейт Редакса.\n\n![](https://i.imgur.com/z2xNnwq.jpg)\n\nПочему мы сохраняем здесь данные именно в стейт Редакса? Потому что мы их можем **переиспользовать**: скорее всего, с этой страницы человек перейдёт внутрь объекта (дома либо участка).\n\nДа, мы внутри той страницы всё равно сделаем запрос (вдруг данные изменились), но мы уже можем показать то, что есть:\n\n![](https://i.imgur.com/8lytp9h.jpg)\n\nНа этой же странице внизу есть блок «Похожие объекты», где такие же карточки. Если данные уже есть, то почему бы их не использовать?\n\n![](https://i.imgur.com/VSZsdu9.jpg)\n\n---\n\nЕсли бы мы не использовали Редакс, то нам бы пришлось данные кидать аж в корневой компонент `<App />` и хранить в его стейте. Не очень удобно.\n\n---\n\nКстати, а как эффективно хранить данные? С сервера приходит массив, что с ним потом делать?\n\n```js\nconst response = {\n  items: [\n    {\n      id: 1107,\n      name: \"1-ое Успенское шоссе\",\n      aliases: [],\n      propertyCategories: [\"country\"],\n      location: {\n        countryId: 1,\n        regionId: 1003,\n        districtId: 1012,\n        routeId: 1178,\n        countryName: \"Россия\",\n        regionName: \"Московская область\",\n        districtName: \"Одинцовский\",\n        routeName: \"Рублёво-Успенское\"\n      },\n      createdAt: \"2016-02-15T19:07:08.916377+03:00\",\n      updatedAt: \"2016-08-23T12:22:43.472+03:00\"\n    },\n    {\n      id: 1137,\n      name: \"2-ое Успенское шоссе\",\n      aliases: [],\n      propertyCategories: [\"country\"],\n      location: {\n        countryId: 1,\n        regionId: 1003,\n        districtId: 1012,\n        routeId: 1178,\n        countryName: \"Россия\",\n        regionName: \"Московская область\",\n        districtName: \"Одинцовский\",\n        routeName: \"Рублёво-Успенское\"\n      },\n      createdAt: \"2016-02-15T19:07:08.916377+03:00\",\n      updatedAt: \"2016-08-23T12:22:26.629+03:00\"\n    },\n    {\n      id: 1973,\n      name: \"Аксаково\",\n      aliases: [],\n      propertyCategories: [\"country\"],\n      location: {\n        countryId: 1,\n        regionId: 1003,\n        districtId: 1720,\n        routeId: 1185,\n        countryName: \"Россия\",\n        regionName: \"Московская область\",\n        districtName: \"Мытищинский\",\n        routeName: \"Дмитровское\"\n      },\n      createdAt: \"2016-06-06T18:02:20.503+03:00\",\n      updatedAt: \"2016-06-06T18:02:20.503+03:00\"\n    },\n    {\n      id: 1174,\n      name: \"Аксиньино\",\n      kindName: \"нас. пункт\",\n      aliases: [],\n      propertyCategories: [\"country\"],\n      location: {\n        countryId: 1,\n        regionId: 1003,\n        districtId: 1012,\n        routeId: 1178,\n        countryName: \"Россия\",\n        regionName: \"Московская область\",\n        districtName: \"Одинцовский\",\n        routeName: \"Рублёво-Успенское\"\n      },\n      createdAt: \"2016-02-15T19:07:08.916377+03:00\",\n      updatedAt: \"2016-02-15T19:07:08.916377+03:00\"\n    },\n    {\n      id: 1100,\n      name: \"Алабино\",\n      kindName: \"нас. пункт\",\n      aliases: [],\n      propertyCategories: [],\n      location: {\n        countryId: 1,\n        regionId: 1003,\n        districtId: 1721,\n        routeId: 1177,\n        countryName: \"Россия\",\n        regionName: \"Московская область\",\n        districtName: \"Наро-Фоминский\",\n        routeName: \"Киевское\"\n      },\n      createdAt: \"2016-02-15T19:07:08.916377+03:00\",\n      updatedAt: \"2016-02-15T19:07:08.916377+03:00\"\n    },\n    {\n      id: 1112,\n      name: \"Александровка\",\n      kindName: \"нас. пункт\",\n      aliases: [],\n      propertyCategories: [\"country\"],\n      location: {\n        countryId: 1,\n        regionId: 1003,\n        districtId: 1009,\n        routeId: 1192,\n        countryName: \"Россия\",\n        regionName: \"Московская область\",\n        districtName: \"Красногорский\",\n        routeName: \"Ильинское\"\n      },\n      createdAt: \"2016-02-15T19:07:08.916377+03:00\",\n      updatedAt: \"2016-02-15T19:07:08.916377+03:00\"\n    }\n  ],\n  pagination: {\n    total: 258,\n    limit: 32,\n    offset: 0\n  }\n};\n```\n\nДопустим, мы даже говорим не про Редакс, а в принципе про эффективную работу с разными типами данных.\n\nОбычно для этого пишут **маппер** (mapper) — функцию, которая преобразовывает из одного формата в другой, более удобный. Какой маппер могли бы мы написать?\n\nЯ предлагаю перевести массив в объект с ключами-айдишниками и завести поле `list`, где будет перечисление этих айдишников. Для этого мы возьмём метод [`.reduce`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce) у массива.\n\nРедьюс принимает два аргумента: функцию-коллбек и начальное значение.\n\nВ функцию-коллбек приходят два аргумента: предыдущее значение и текущее, а возвращать она должна **конечное** значение. Она работает как аккумулятор: к накопленному прошлому добавляет текущее.\n\n```js\nfunction mapItemsToObjects(items) {\n  const reducedItems = items.reduce(function(prevValue, currentValue) {\n    // мы будем использовать два нововведения ES2015\n    // спред-оператор https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax\n    // и computed property names https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names\n    return {\n      ...prevValue,\n      [currentValue.id]: currentValue\n    };\n  }, {});\n\n  return {\n    ...reducedItems, // скопируем содержимое reducedItems\n    list: items.map(function(item) {\n      return item.id; // пройдёмся по массиву и вернём только айдишники\n    })\n  };\n}\n\nconst formattedProperties = mapItemsToObjects(response.items);\n```\n\nЧто мы получили?\n\n```js\nformattedProperties = {\n  \"1100\": {\n    id: 1100,\n    name: \"Алабино\",\n    kindName: \"нас. пункт\",\n    aliases: [],\n    propertyCategories: [],\n    location: {\n      countryId: 1,\n      regionId: 1003,\n      districtId: 1721,\n      routeId: 1177,\n      countryName: \"Россия\",\n      regionName: \"Московская область\",\n      districtName: \"Наро-Фоминский\",\n      routeName: \"Киевское\"\n    },\n    createdAt: \"2016-02-15T19:07:08.916377+03:00\",\n    updatedAt: \"2016-02-15T19:07:08.916377+03:00\"\n  },\n  \"1107\": {\n    id: 1107,\n    name: \"1-ое Успенское шоссе\",\n    aliases: [],\n    propertyCategories: [\"country\"],\n    location: {\n      countryId: 1,\n      regionId: 1003,\n      districtId: 1012,\n      routeId: 1178,\n      countryName: \"Россия\",\n      regionName: \"Московская область\",\n      districtName: \"Одинцовский\",\n      routeName: \"Рублёво-Успенское\"\n    },\n    createdAt: \"2016-02-15T19:07:08.916377+03:00\",\n    updatedAt: \"2016-08-23T12:22:43.472+03:00\"\n  },\n  \"1112\": {\n    id: 1112,\n    name: \"Александровка\",\n    kindName: \"нас. пункт\",\n    aliases: [],\n    propertyCategories: [\"country\"],\n    location: {\n      countryId: 1,\n      regionId: 1003,\n      districtId: 1009,\n      routeId: 1192,\n      countryName: \"Россия\",\n      regionName: \"Московская область\",\n      districtName: \"Красногорский\",\n      routeName: \"Ильинское\"\n    },\n    createdAt: \"2016-02-15T19:07:08.916377+03:00\",\n    updatedAt: \"2016-02-15T19:07:08.916377+03:00\"\n  },\n  \"1137\": {\n    id: 1137,\n    name: \"2-ое Успенское шоссе\",\n    aliases: [],\n    propertyCategories: [\"country\"],\n    location: {\n      countryId: 1,\n      regionId: 1003,\n      districtId: 1012,\n      routeId: 1178,\n      countryName: \"Россия\",\n      regionName: \"Московская область\",\n      districtName: \"Одинцовский\",\n      routeName: \"Рублёво-Успенское\"\n    },\n    createdAt: \"2016-02-15T19:07:08.916377+03:00\",\n    updatedAt: \"2016-08-23T12:22:26.629+03:00\"\n  },\n  \"1174\": {\n    id: 1174,\n    name: \"Аксиньино\",\n    kindName: \"нас. пункт\",\n    aliases: [],\n    propertyCategories: [\"country\"],\n    location: {\n      countryId: 1,\n      regionId: 1003,\n      districtId: 1012,\n      routeId: 1178,\n      countryName: \"Россия\",\n      regionName: \"Московская область\",\n      districtName: \"Одинцовский\",\n      routeName: \"Рублёво-Успенское\"\n    },\n    createdAt: \"2016-02-15T19:07:08.916377+03:00\",\n    updatedAt: \"2016-02-15T19:07:08.916377+03:00\"\n  },\n  \"1973\": {\n    id: 1973,\n    name: \"Аксаково\",\n    aliases: [],\n    propertyCategories: [\"country\"],\n    location: {\n      countryId: 1,\n      regionId: 1003,\n      districtId: 1720,\n      routeId: 1185,\n      countryName: \"Россия\",\n      regionName: \"Московская область\",\n      districtName: \"Мытищинский\",\n      routeName: \"Дмитровское\"\n    },\n    createdAt: \"2016-06-06T18:02:20.503+03:00\",\n    updatedAt: \"2016-06-06T18:02:20.503+03:00\"\n  },\n  list: [1107, 1137, 1973, 1174, 1100, 1112]\n};\n```\n\nДля чего мы это сделали? Когда нам нужно обратиться к конкретному айдишнику — мы пишем `formattedProperties[1100]`, но при этом мы можем итерироваться (проходить один за одним) по айдишникам, которые у нас лежат в `formattedProperties.list`.\n\nПоэтому когда нам нужно будет вывести список с данными, мы напишем очень простой код:\n\n```jsx\nfunction PropertiesList() {\n  return (\n    <ul>\n      {formattedProperties.list.map(function(id) {\n        const data = formattedProperties[id];\n\n        return (\n          <li>\n            <a href={`/properties/${data.id}`}>\n              {data.name} на шоссе {data.location.routeName}\n            </a>\n          </li>\n        );\n      })}\n    </ul>\n  );\n}\n```\n\nБез этого нам бы пришлось городить `response.items.find(function(item) { return item.id === 1001 })`. Не очень удобно.\n\n## Готовим АПИ Редакса в домашних условиях\n\nОкей, со смыслом Редакса и даже с форматтерами мы разобрались, теперь давайте воссоздадим АПИ Редакса на `setState`.\n\nРедакс работает как [EventEmitter](https://en.wikipedia.org/wiki/Event-driven_architecture): когда происходит **событие**, вызывается **листенер**. События тут называются **экшенами**, а листенеры — **редьюсерами** (да, в них тоже приходит предыдущий стейт).\n\nВы знали, что в `setState()` можно передать не только объект, но и функцию, которая должна вернуть новый стейт? Это называется [функциональным сетСтейтом](https://medium.freecodecamp.org/374f30401b6b). У функции есть аргумент `prevState` — предыдущий стейт, он-то там и понадобится.\n\nЧто такое экшен Редакса? Это обычный объект, в котором есть поле `type`. По этому полю редьюсер понимает, что нужно сделать со стейтом. Экшен вызывается через **диспатч**.\n\nПора воссоздавать!\n\n<iframe src=\"https://codesandbox.io/embed/48rnjr52lw?module=%2Fsrc%2FCounter.js&view=editor\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n## Итог\n\nСегодня мы разобрались с философией Редакса: в глобальном стейте храним только то, что нельзя переиспользовать [через родителей](https://medium.com/@jmuse/d86394da2b50); заодно мы познакомились с концепцией мапперов/трансформеров/форматтеров: функций, которые переводят данные из одного вида в другой.\n\nПосле этого мы воссоздали АПИ Редакса с его редьюсерами-экшенами-диспатчем на самом обычном `setState()` и познакомились с функциональным `setState()`-ом.\n",
      "isPublic": true,
      "id": "fXVmCZhOpt",
      "stageId": "rHAh7OXEFL"
    }
  ]
}