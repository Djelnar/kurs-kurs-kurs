{"stage":2,"title":"Работа человека с интерфейсом через эвенты","subTitle":"Интерфейс это не статичная картинка, но как понять что человек делает с ним?","markdown":"Привет! Девятый урок и мы подбираемся к настоящему фронтэнду — передней части продукта, так сказать. Не вёрстке (пускай и на Реакте со СК и Роутером), а именно что фронтэнду.\n\nНо для начала — пару обязательных технических знаний.\n\n## Дев тулз\n\nЕсли вы уже начали экспериментировать с кодом, то вы, наверное, заметили, что вслепую сложно что-то делать.\n\nЛюди с [курса по вёрстке](https://erodionov.ru/courses/verstka) знают про [дев тулз](https://developers.google.com/web/tools/chrome-devtools/) — специальная утилита браузера, которая показывает дерево элементов и его стили.\n\nВо всех современных браузерах (от Эджа до Хрома и Сафари) есть ДевТулз — инструменты разработчика. Обычно они делятся на кучу вкладок, но нас интересуют две: дерево элементов и консоль.\n\nВ консоль можно писать через функцию `console.log()`.\n\n![](https://i.imgur.com/NWwEdQI.png)\n\nДля Хрома и Файрфокса поставьте [Реакт ДевТулз](https://github.com/facebook/react-devtools), тогда у вас будет доступ ещё и к компонентам с их стейтами и пропами. Удобно.\n\n## ДОМ или дерево элементов\n\nНа [ДОМе](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction) (DOM, Document Object Model) построена вся работа браузеров. ДОМ, как вы понимаете, это **дерево элементов**, а Виртуал ДОМ — это технология, работающая с двумя деревами: она сравнивает их между собой и вычленяет маленькие изменения, чтобы экономно обновить ДОМ.\n\nА как, кстати, работать с реальным ДОМом? Это же не магия какая-то, которая доступна только разработчикам библиотек типа Реакта. Веб вообще славится своей открытостью: всем доступно всё.\n\nРабота с ДОМом **императивна**: вы должны указать \"возьми этот элемент и сделай с ним что-нибудь\".\n\nРабота с элементами в Реакте **декларативна**: вы указываете \"у этого элемента такие свойства\".\n\nНепонятно? Согласен. Давайте разбирать на примерах.\n\n## Эвенты\n\nЕсли человек куда-то кликнул, проскроллил или ещё что-то сделал с интерфейсом, как это отследить? Как поставить хотя бы консоль.лог на это событие?\n\n[Событие](https://developer.mozilla.org/en-US/docs/Web/Events)! Вот как работает интерфейс: на событиях, эвентах. Произошло событие — мы должны его **обработать**. Как это лучше всего сделать? Наверное, функцией? Вызвать функцию когда произошло событие — это звучит логично.\n\nТак оно и есть: когда происходит эвент, вызывается его хэндлер (обработчик). Хэндлер эвента это функция, в которую приходят аргументы, в этой функции мы делаем что-нибудь с эвентом, хоть консоль.логом выводим.\n\nСудя по [МДН](https://developer.mozilla.org/en-US/docs/Web/Events), эвентов очень много, но мы будем рассматривать два простейших: клик по элементу и, допустим, фокус по инпуту.\n\n> Кстати, если вам интересно, почему я не перевожу термины — чтобы вам было проще с ними работать и гуглить информацию по ним.\n\n> Почитывая в прошлом Хабрахабр, я заметил идиотские переводы простейших терминов и не понимал даже как гуглить о чём идёт речь.\n\n### Работа с эвентами в браузерном Джсе\n\nКак я и говорил, в браузерном Джсе мы работаем императивно: берём элемент и вешаем на него хэндлер.\n\n```html\n<button id=\"my-button\">click me</button>\n\n<script>\n  // ищем элемент через document.getElementById()\n  // https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById\n  const button = document.getElementById(\"my-button\");\n\n  // вешаем на него клик\n  button.addEventListener(\"click\", function(event) {\n    // при клике выводим в консоль данные эвента\n    console.log(event);\n  });\n</script>\n```\n\nСкажем так, выглядит не очень удобно. А что если мы сможем указать прямо у элемента атрибут onClick и туда передать функцию?\n\nИ [мы можем](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Events): существуют три вида работы с эвент хэндлерами и `addEventListener` как раз один из них.\n\nКакой второй способ? Через атрибут `onclick` указать функцию и что в неё придёт:\n\n```html\n<button onclick=\"handleMyButtonClick(event)\">\n  click me\n</button>\n\n<script>\n  function handleMyButtonClick(event) {\n    console.log(event);\n  }\n</script>\n```\n\nВыглядит уже намного лучше и понятнее, верно? Этот путь находится очень рядом с системой эвентов Реакта.\n\n### Работа с эвентами в Реакте\n\nВ примере выше есть несколько проблем:\n\n1.  непонятный стиль кода вместо camelCase (`onClick` читается легче чем `onclick`),\n2.  функция зачем-то передаётся как строка,\n3.  функция как будто вызывается прямо в атрибуте, но на деле нет,\n4.  нет системы ошибок: если забыл объявить `handleMyButtonClick`, то пользователь узнает об этом только при клике на кнопку, хотя Еслинт мог бы подсветить что такой функции нет.\n\nВсе четыре проблемы решил Реакт через лозунг \"явное лучше неявного\". С первым пунктом всё понятно, давайте пройдёмся по остальным трём.\n\n#### Функция передаётся как функция, а не строка\n\nМы знаем, что в Джсхе мы можем выполнять любой Джс-код в `{}`: хоть `{2+2}`, хоть `{getUserInfo(userId)}`. Пропы тоже поддерживают этот синтаксис:\n\n```jsx\nimport React from \"react\";\nimport styled from \"styled-components\";\n\nconst Button = styled.button`\n  // умножим размер на 10\n  // чтобы получить размер паддингов\n  padding: ${props => p.size * 10}px;\n`;\n\n<Button size={2 + 2}>Button of 4</Button>;\n```\n\nПо этой причине мы на клик по кнопке можем передать функцию.\n\n```js\n// Button.js\nfunction handleClick(event) {\n  console.log(event);\n}\n\n<button onClick={handleClick(event)}>click me</button>;\n```\n\nНо стоп! Стоп-стоп-стоп! Если мы так сделаем, откроем страницу, то даже без клика мы получим консоль.лог в браузере.\n\n<iframe src=\"https://codesandbox.io/embed/k3kp4l0p8v\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\nКак так?\n\n#### Функция не должна вызываться в пропе\n\nВ проп должна передаться ссылка на функцию, а не её вызов.\n\n```jsx\n// неправильно — вызовется сразу как компонент станет доступен\n<button onClick={handleClick(event)}>click me</button>\n\n// правильно — при клике на элемент вызовется эта функция\n<button onClick={handleClick}>click me</button>\n```\n\n> Как понять, что в Реакте приходит на этом `onClick`? Читайте официальную документацию: [Handling Events](https://reactjs.org/docs/handling-events.html) и [`SyntheticEvent`](https://reactjs.org/docs/events.html).\n> Первая статья рассказывает о работе эвентов, вторая — о специальном типе данных `SyntheticEvent`, который отличается от дефолтного объекта браузера, который приходит в хэндлере эвента.\n\nЧетвёртая проблема, как вы понимаете, тоже решена: мы в Джсхе передаём обычный джаваскрипт, поэтому если наша функция не будет существовать, то Еслинт об этом расскажет — либо в редакторе (если вы настроили интеграцию), либо при сборке проекта (об этом в будущем).\n\n## Итог\n\nВ этом уроке мы не только разобрались с системой эвентов в Реакте и поняли чем она мощна, но и поработали с браузерными ДОМом и эвентами.\n\nА говорят, что не нужно начинать знакомство с фронтэндом через популярные библиотеки и фреймворки! Как видите, мы учимся _чистому Джсу_ как раз потому что Реакт не использует свой птичий язык шаблонов и заставляет работать с чистым Джсом.\n\nКстати, как попрактиковаться в этих знаниях? Отловили мы эвент, дальше-то что? Узнаете в следующем уроке — там мы будем соединять стейт и эвенты.\n","id":"oYajvJsdaa","stageId":"rHAh7OXEFL"}