{"stage":2,"title":"Стейты компонентов как источник данных","subTitle":"В компонентном подходе компонентны не только рендер и стили, но и логика","markdown":"# Принципы Реакта\n\n<iframe width=\"100%\" height=\"541\" src=\"https://www.youtube.com/embed/f11f8ksArp4\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe>\n\n# Эвенты, классовые компоненты, this и стейт\n\n<iframe width=\"100%\" height=\"541\" src=\"https://www.youtube.com/embed/eQyGf8Fe_YQ\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe>\n\n# Работа с данными\n\n<iframe width=\"100%\" height=\"541\" src=\"https://www.youtube.com/embed/tj3wrvHdyuo\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe>\n\nОкей, с вёрсточкой разобрались: поняли, как верстать компонентами, переехали с селекторов на Стайлед-компонентс, поиграли с Реакт-роутером, но пора двигаться дальше.\n\nГде хранить данные? Как с ними работать? Нужно ли писать сервис-провайдеры-фабрики как в Ангуларе?\n\n## Стейты\n\nСлава богу, не нужно! Реакт несложный даже в работе с данными и оперирует обычными функциями, которые возвращают новые данные.\n\nКак работает Реакт? У компонента есть **стейт** — состояние данных, есть **рендер** — вёрстка, в сумме это то самое уравнение `ui = render(state)` из первого урока.\n\nЧто это значит? **Когда обновляется стейт, вызывается рендер и строится новый интерфейс**.\n\nДа, само. Да, нужно всего лишь обновить стейт, рендер сам вызовется. Да, это так удобно.\n\nДа, если вы хотите поставить кнопке красный цвет, не нужно писать `document.getElementById(\"my-button\").style.background = 'red'`, достаточно просто поставить новый стейт.\n\nДа, если вы хотите чекбоксу поставить `checked`, можно в стейт положить `checked: true` и передать пропом `checked={state.checked}`.\n\nДа, в стейте можно хранить даже данные с сервера.\n\nДа, в стейте хранят и данные заполненных форм.\n\nДа, это работает как на маленьких проектах, так и на крупных.\n\nДа, Редакс уже близко. Редакс это всего лишь глобальный стейт, а не компонентный.\n\n### Посортируем список фильмов\n\nЧто такое стейт? Это просто объект с данными, к которому можно обратиться. Давайте в виде псевдокода представим что у нашего компонента есть стейт.\n\n```jsx\nconst state = {};\n\n// рендерим\nfunction Movies() {\n  return (\n    <div>\n      <p>Sort by:</p>\n      <button>alphabetical</button>\n      <button>date released</button>\n      <button>reviews count</button>\n      <button>average rating</button>\n      ...movies list\n    </div>\n  );\n}\n```\n\nВ этом стейте мы можем хранить данные. Почему в стейте, а не просто константой? **Стейт — для динамических данных**, а в интерфейсе у нас есть сортировка фильмов.\n\nОбновилась сортировка → обновился список фильмов → обновился интерфейс.\n\nКаждой кнопке мы добавим проп `onClick`, внутри которого будет функция, которая будет вызывать нашу функцию `handleClick` и передавать туда поле, по которому нужно отсортировать. Заодно наполним стейт начальными данными.\n\n```jsx\nconst state = {\n  movies: [\n    {\n      id: 1,\n      title: \"City Lights\",\n      year: 1931,\n      rating: 8.5\n    },\n    {\n      id: 2,\n      title: \"American History X\",\n      year: 1998,\n      rating: 8.5\n    },\n    {\n      id: 3,\n      title: \"Wild Strawberries\",\n      year: 1957,\n      rating: 8.1\n    }\n  ]\n};\n\nfunction changeSort(kind) {}\n\n// рендерим\nfunction Movies() {\n  return (\n    <div>\n      <p>Sort by:</p>\n      <button onClick={() => changeSort(\"alphabetical\")}>alphabetical</button>\n      <button onClick={() => changeSort(\"date\")}>date released</button>\n      <button onClick={() => changeSort(\"rating\")}>average rating</button>\n      ...movies list\n    </div>\n  );\n}\n```\n\nТеперь давайте представим, что у нас есть некая магическая функция `setState`, которая принимает в себя данные и обновляет стейт.\n\nПричем, что удобно, обновляет только указанные данные: например, если у вас в стейте три поля `isFetching, movies, error`, а вы вызовете `setState({ isFetching: true })`, то `movies` и `error` останутся такими же, какими и были.\n\nОкей, у нас есть эта функция, давайте теперь напишем нашу функцию `changeSort()`:\n\n```js\n// заведём функцию сортировки\n// https://davidwalsh.name/array-sort\nfunction sortObjectsByField(field, leftObject, rightObject) {\n  return leftObject[field] - rightObject[field];\n}\n\nfunction changeSort(kind) {\n  // заведём объект,\n  // который будет приводить\n  // kind к полю у объекта\n  const sortFieldsToKey = {\n    alphabetical: \"title\",\n    date: \"year\",\n    rating: \"rating\"\n  };\n\n  // получим поле у объектов,\n  // по которому нужно сортировать\n  const currentSortField = sortFieldsToKey[kind];\n\n  // сохраним текущее поле\n  // чтобы подсветить кнопку активным\n  // ЭТА ФУНКЦИЯ ПРИДУМАНА, ЕЁ НЕ СУЩЕСТВУЕТ\n  setState({ orderField: kind });\n\n  // отсортируем фильмы\n  setState({\n    movies: state.movies.sort(function(leftObj, rightObj) {\n      return sortObjectsByField(currentSortField, leftObj, rightObj);\n    })\n  });\n}\n```\n\nЧто дальше? В рендере мы просто [выведем](https://reactjs.org/docs/lists-and-keys.html) эти фильмы через метод `.map()` у массива.\n\nЭтот метод проходится по массиву, на каждом элементе вызывает функцию, которая должна вернуть новое значение под этим же индексом массива, в нашем случае — Реакт-компонент.\n\n_Если тут ничего непонятно — перечитайте третий урок про базовый джаваскрипт._\n\n```jsx\nfunction Movies() {\n  return (\n    <div>\n      <p>Sort by:</p>\n      <button onClick={() => changeSort(\"alphabetical\")}>alphabetical</button>\n      <button onClick={() => changeSort(\"date\")}>date released</button>\n      <button onClick={() => changeSort(\"rating\")}>average rating</button>\n\n      {state.movies.map(function(movie) {\n        // movie это объект с данными\n\n        // возвращаем Реакт-компонент\n        return (\n          <a href={`/movies/${movie.id}`} key={movie.id}>\n            {movie.title} ({movie.year}) | rating {movie.rating}\n          </a>\n        );\n      })}\n    </div>\n  );\n}\n```\n\n> Что ещё за фигурные скобки? Это Джсх, в фигурных скобках [может быть](https://reactjs.org/docs/introducing-jsx.html#embedding-expressions-in-jsx) любое Джс-выражение: хоть `2 + 2`, хоть обращение к объекту `user.firstName`, хоть вызов функции `formatName(user)`.\n\n> Что за проп `key`? Это [обязательный](https://reactjs.org/docs/lists-and-keys.html#keys) у списков проп, который помогает Реакту отделить один компонент от другого при обновлении данных. Реакт справится и без них, но лучше с ними.\n\nМы же прошлись по массиву и получили новый массив, в котором есть Реакт-компоненты. Их мы и отрендерили.\n\nЕсли упрощать до обычного Джаваскрипта, мы могли бы новый массив закрепить за константой и обратиться к ней в Джсхе:\n\n```jsx\nfunction Movies() {\n  const movies = state.movies.map(function(movie) {\n    // movie это объект с данными\n\n    // возвращаем Реакт-компонент\n    return (\n      <a href={`/movies/${movie.id}`} key={movie.id}>\n        {movie.title} ({movie.year}) | rating {movie.rating}\n      </a>\n    );\n  });\n\n  return (\n    <div>\n      {/* кнопки сортировки */}\n\n      {movies}\n    </div>\n  );\n}\n```\n\nВ итоге мы будем рендерить список фильмов, а при клике на сортировку — сортировать его и автоматически обновлять стейт, потому что у нас есть вымышленная функция `setState()`: от неё зависит Реакт и обновляет рендер сразу же после того как обновится стейт.\n\n## Итог\n\nНа этом наш урок подходит к концу.\n\nСегодня мы разобрались с тем, как у компонентов могут быть стейты, в которых хранятся и обновляются данные через `setState()`.\n\nВажно помнить, что всю работу по обновлению интерфейса Реакт берёт на себя, наша задача — писать стейт, обновлять его и описать в рендере вёрстку от этого стейта.\n\n---\n\nКстати, а как быть, если хочется не ссылку рендерить через `<a>`, а свой компонент? Как туда передать стейт?\n\nПропами!\n\n```jsx\nfunction Movie(props) {\n  return (\n    <a href={`/movies/${props.id}`}>\n      {props.title} ({props.year}) | rating {props.rating}\n    </a>\n  );\n}\n\nfunction Movies() {\n  const movies = state.movies.map(function(movie) {\n    // movie это объект с данными\n\n    // возвращаем Реакт-компонент\n    return (\n      <Movie\n        id={movie.id}\n        year={movie.year}\n        rating={movie.rating}\n        key={movie.id}\n      >\n        {movie.title}\n      </Movie>\n    );\n  });\n\n  return (\n    <div>\n      {/* кнопки сортировки */}\n\n      {movies}\n    </div>\n  );\n}\n```\n","id":"pN52548BH1","stageId":"rHAh7OXEFL"}