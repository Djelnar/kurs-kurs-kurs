{"stage":3,"title":"Серверный рендеринг","subTitle":"Приходим к бэкэнду фронтэнда","markdown":"В прошлом уроке мы разобрались с билдами и деплоями, но есть одна проблема: а как же нам быть с поисковыми системами?\n\nОни то умеют отрабатывать Джаваскрипт, то не умеют, но нам же нужно надёжное решение, мы не можем надеяться на волю Гугла или Яндекса. Для этого мы будем рендерить приложение на сервере.\n\nКак было раньше, лет 10 назад? Помните, я говорил про MVC? Был проект, который делал запрос к базе данных, затем его рендерил в шаблон и отдавал готовую вёрстку в браузер.\n\nПсевдокодом это выглядит так:\n\n```js\n// подготовленные данные из БД\nconst data = {\n  title: \"2-комнатная квартира в центре Хамовников\",\n  area: 142.2\n};\n\n// шаблон с местами под данные\n<template>\n  <h1>{{data.title}}</h1>\n  <p>{{data.area}} м²</p>\n</template>\n\n// рендер в готовую вёрстку,\n// render не из ReactDOM,\n// а из какого-нибудь шаблонизатора\nconst html = render(data, template);\n```\n\nПо этой причине поисковики (и люди) получали готовую вёрстку и могли её парсить, изучать.\n\nСейчас всё по-другому: поисковикам (и людям) отдаётся небольшой ХТМЛ с `<div id=\"root\"></div>`, куда Реакт рендерит приложение.\n\nНо Реакт-то написан на Джаваскрипте, а поисковики его не исполняют! Всё, что они знают о вашем сайте — это `<div id=\"root\"></div>`. Не очень круто.\n\n## Серверный рендеринг\n\nСерверный рендеринг это процесс рендера приложения на сервере и отдача готовой вёрстки. Как раньше, только у нас не большой проект с бэкэндом и фронтэндом вместе, а небольшой сервер, который занимается только рендером фронтэнда на сервере.\n\nДля чего нужен ССР (server-side rendering)?\n\nВ первую очередь для людей: сервера намного мощнее чем ноутбуки и планшеты людей, поэтому проще подготовить готовую вёрстку и отдать её, чем ждать пока выполнится ваш Джаваскрипт-код. Почитайте про [Ресурс Тайминг](https://developers.google.com/web/tools/chrome-devtools/network-performance/understanding-resource-timing) в блоге Гугла — очень большой простор для оптимизации.\n\nВо вторую очередь для тех самых поисковиков. Поисковый трафик до сих пор остаётся самым сильным, поэтому компании в него вкладываются и будут вкладываться и вы должны очень чутко следить за тем, чтобы ваш новейший фронтэнд работать хорошо.\n\n> Да, если сеошники начинают ныть, что Реакт не приспособлен для СЕО и они не возьмутся за проект — смело им показывайте мой кейс ([29 июня 2017](https://t.me/RodionovRodionovRodionov/207) и полгода спустя, [24 декабря 2017](https://t.me/RodionovRodionovRodionov/474) > ![](https://i.imgur.com/owgyOgP.png)\n\n---\n\nОкей, нужда понятна, как это всё реализовать?\n\n## ХТТП-серверы и Нода\n\nНам же нужно отдавать готовую вёрстку на запрос браузера? Для этого нам нужно написать **сервер**, который будет работать с ХТТП-запросами.\n\nСервер мы будем писать на Джаваскрипте, а запускать — Нодой, которую вы ставили в начале курса.\n\nНода это специальное окружение, где выполняется джс. Нода дарит [свой АПИ](https://nodejs.org/api/index.html) (а браузеры — [свой](https://developer.mozilla.org/en-US/docs/Web/API)), например, для работы с [файловой системой](https://nodejs.org/api/fs.html), [криптографией](https://nodejs.org/api/crypto.html) или [операционной системой](https://nodejs.org/api/os.html) и [путями в ней](https://nodejs.org/api/path.html).\n\nНас интересует [ХТТП](https://nodejs.org/api/http.html), но нативный АПИ слишком низкоуровневый и многосложный, поэтому мы возьмём [Экспресс](http://expressjs.com/) — удобную библиотеку.\n\n> Такие прокладки дают более удобный АПИ, чем нативный, но за это нужно расплачиваться скоростью работы: если бы мы использовали `http` Ноды, у нас бы приложение работало быстрее, потому что Экспресс тоже затрачивает время на выполнение своего кода; это называется **оверхедом**.\n> К счастью, речь идёт о совсем крошечных значениях и в реальной жизни редко кто находит Экспресс узким местом в приложении.\n\nПока мы в браузерах с помощью Бейбеля и Вебпака пришли к `import/export`, модули в Ноде делались (и пока что делаются) через функцию `require()`.\n\nДавайте соберём [небольшую демку](http://expressjs.com/en/starter/hello-world.html) на экспрессе, которая будет на двух разных страницах отдавать разный контент. Код будем писать в `/server.js`\n\n```js\nconst express = require(\"express\");\n\n// создаём приложение\nconst app = express();\n\nconst text = \"Hello World!\";\nconst json = { ok: true };\nconst html = '<html><p style=\"color: red\">test</p></html>';\n\n// при ГЕТ-запросах на разные адреса\n// отдадим разный контент через res.send\napp.get(\"/\", function(req, res) {\n  return res.send(text));\n}\n\napp.get(\"/json\", function(req, res) {\n  return res.send(json));\n}\n\napp.get(\"/html\", function(req, res) {\n  return res.send(html));\n}\n\n// запускаем сервер на порту 3000\napp.listen(3000, function() {\n  console.log(\"Example app listening on port 3000!\");\n});\n```\n\n![](https://i.imgur.com/lexb1aQ.png)\n\nЭкспресс работает на уже знакомых вам коллбеках, в которые приходят два параметра: [`req[uest]`](http://expressjs.com/en/4x/api.html#req) и [`res[ponse]`](http://expressjs.com/en/4x/api.html#res). В реквесте хранится информация о реквесте (например, хедеры, тело, куки и проч), в респонсе — методы и информация о респонсе.\n\n![](https://i.imgur.com/DoIGMWE.png)\n\nЧерез метод [`res.send()`](http://expressjs.com/en/4x/api.html#res.send) мы посылаем ХТТП-ответ. Перед этим мы можем через методы [`res.cookie()`](http://expressjs.com/en/4x/api.html#res.cookie),[`res.set()`](http://expressjs.com/en/4x/api.html#res.set), [`res.status()`](http://expressjs.com/en/4x/api.html#res.status) поставить куки, ХТТП-хедеры или [ХТТП-статус-код](https://httpstatuses.com/).\n\n> Да, этим мы мутируем объект `res`, ну а что поделать — такой вот АПИ у Экспресса. Мутабельность это всё ещё плохо, потому что явное лучше неявного.\n\nКак запустить наш сервер? Командой `node ./server.js`.\n\n---\n\nОкей, что нам дают эти знания? Теперь мы немного умеем работать с ХТТП, понимаем что для этого нужно написать сервер на Ноде с помощью Экспресса.\n\n## Серверный рендеринг — теория\n\nНаша задача отрендерить Нодой Реакт-приложение и затем отдать готовую вёрстку.\n\nПсевдокодом это выглядит примерно так:\n\n```js\nconst express = require(\"express\");\nconst { render } = require(\"react-dom/server\"); // например\nconst ReactApp = require(\"./src/App\");\n\n// создаём приложение\nconst app = express();\n\n// на любом адресе рендерим Реакт-приложение\n// потому что Реакт-роутер разберётся что именно нужно рендерить\napp.get(\"/*\", function(req, res) {\n  // на каждом запросе заново строим Реакт-приложение\n  // потому что у каждого клиента свой запрос\n  const html = render(React.createElement(ReactApp));\n\n  return res.send(html);\n});\n\n// запускаем сервер на порту 3000\napp.listen(3000, function() {\n  console.log(\"Example app listening on port 3000!\");\n});\n```\n\nЧто характерно, этот псевдокод почти рабочий: разве что вместо `render()` из `react-dom/server` мы импортим [`renderToString()`](https://reactjs.org/docs/react-dom-server.html#overview) оттуда же. Фиксанём.\n\n```js\nconst express = require(\"express\");\nconst { renderToString } = require(\"react-dom/server\");\nconst ReactApp = require(\"./src/App\");\n\n// создаём приложение\nconst app = express();\n\n// на любом адресе рендерим Реакт-приложение\n// потому что Реакт-роутер разберётся что именно нужно рендерить\napp.get(\"/*\", function(req, res) {\n  // на каждом запросе заново строим Реакт-приложение\n  // потому что у каждого клиента свой запрос\n  const html = renderToString(React.createElement(ReactApp));\n\n  return res.send(html);\n});\n\n// запускаем сервер на порту 3000\napp.listen(3000, function() {\n  console.log(\"Example app listening on port 3000!\");\n});\n```\n\nЕсли мы теперь каждый запрос будем пропускать через ССР-прокси, то второе, что нам нужно сделать — заменить в `src/index.js` `ReactDOM.render()` на [`ReactDOM.hydrate()`](https://reactjs.org/docs/react-dom.html#hydrate).\n\nНо если мы запустим теперь `node server.js`, то получим кучу ошибок: от `Unexpected token import`.\n\nЕсть два способа это решить: использовать `babel-node` (который будет на лету преобразовывать — но это грозит неплохим оверхедом) и настраивать Вебпак чтобы при билде он собирал отдельный бандл (конечный файл), который вы подключите в Ноду как обычный модуль через `require()`.\n\nВообще, почему так сложно? Почему Нода не поддерживает современный Джаваскрипт? Чисто технически — [поддерживает](https://node.green/), но есть три нюанса.\n\n### Различие Ноды и браузерного Джса\n\n#### Модули\n\nПервый — модули.\n\nРаньше в Джсе вообще никаких модулей не было, потом появился [RequireJS](http://requirejs.org/) который их эмулировал и использовал подход [AMD](http://requirejs.org/docs/whyamd.html) (Asynchronous Module Definition).\n\nБыл ещё CommonJS (он же ServerJS) — спецификация, идея которой была в использовании Джса на серверной стороне, в том числе с модулями. Как вы понимаете, победила Нода, но систему модулей себе она забрала именно оттуда.\n\nПосле — комитет TC39, развивающий Экмаскрипт (стандарт, на котором реализован Джаваскрипт) вернулся к своей работе и каждый год обновляет Экмаскрипт. Самый громкий релиз был ES2015 (он же ES6), частью которого и были модули, или [ES modules](http://2ality.com/2014/09/es6-modules-final.html). Это уже знакомые вам import/export.\n\nПоддержка ес-модулей [будет](https://medium.com/the-node-js-collection/an-update-on-es6-modules-in-node-js-42c958b890c), но, скорее всего, через расширение `.mjs`. Во всяком случае, сейчас её нет.\n\n#### Поддержка ES2015 и выше\n\nВторая проблема — поддержка этого самого Экмаскрипта.\n\nЕсли мы делаем фронтэнд, благодаря Бейбелю мы можем писать современный Джс даже если он недоступен в браузерах. С Нодой современный Джс всё ещё недоступен.\n\nДа, можно компилировать тем же Бейбелем, но плата за это — сложно читаемые исходники. Зайдите на сайт Бейбеля, [попробуйте](http://babeljs.io/repl/) вбить какой-нибудь свой Реакт-код туда — вывод будет сложно понять.\n\n#### Невозможность импорта картинок и прочего\n\nВебпак работает с любым типом файлов — был бы нужный лоадер, хоть [markdown-loader](https://www.npmjs.com/package/markdown-loader), хоть пдф через [file-loader](https://www.npmjs.com/package/file-loader).\n\nВ Ноде, конечно же, такого нет (как и в ес-модулях, в общем-то) — каждый реквайр трактуется как Джс, а не как пнг.\n\n### Решения\n\n#### Сложный: делать отдельный бандл\n\nВ [Купибилете](https://www.kupibilet.ru/) ребята подготавливают отдельный CommonJS-бандл с Реакт-приложением, который потом реквайрят в `server.js`.\n\n**Плюсы:**\n\n* нет оверхеда на преобразование Бейбелем на лету\n\n**Минусы:**\n\n* сложно настроить\n\n#### Лёгкий: использовать `babel-node` вместо `node`\n\n**Плюсы:**\n\n* настроить легче\n\n**Минусы:**\n\n* сильный оверхед: код преобразовывается на каждом запросе и на это уходят ресурсы сервера и время\n\nЛично я использую `babel-node` на этом сайте: у меня не такие большие запросы чтобы думать об оверхеде.\n\n##### `asset-require-hook`\n\nОдин из вопросов настройки это те самые ресурсы типа .жпг или .свг, которые вы импортите и обрабатываете Вебпаком.\n\nДля этого используется [asset-require-hook](http://npm.im/asset-require-hook): специальный модуль, который отлавливает (hook) такие импорты и преобразовывает их в ссылки.\n\nНастройка у него достаточно примитивная:\n\n```js\nrequire(\"asset-require-hook\")({\n  extensions: [\".jpg\", \".jpeg\", \".png\", \".gif\", \".svg\"], // нужны точки обязательно\n  publicPath: process.env.PUBLIC_URL,\n  name: \"/static/media/[name].[hash:8].[ext]\" // https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/config/webpack.config.prod.js#L167\n});\n```\n\n##### `isomorphic-fetch`\n\nВ Ноде нет встроенного Фетча, поэтому используется [node-fetch](http://npm.im/node-fetch), но чтобы не заменять весь проект им, существует ещё один хук: [isomorphic-fetch](http://npm.im/isomorphic-fetch).\n\nПросто импортните его:\n\n```js\nrequire(\"isomorphic-fetch\");\n```\n\n##### `window-or-global`\n\nВ Ноде также нет объекта Window, который существует в браузерах. Для этого используют модуль [window-or-global](http://npm.im/window-or-global), который импортят в Реакт-приложении когда нужно обратиться к `window`.\n\n## Серверный рендеринг — собираем вместе\n\nОкей, мы разобрались с проблемами и нашли решения, давайте соберём всё вместе.\n\nНам нужно на сервере рендерить:\n\n* Реакт — используем `renderToString` из `react-dom/server`,\n* [Реакт-роутер](https://reacttraining.com/react-router/web/guides/server-rendering) — мы же должны отдавать корректную страницу,\n* Заголовки через [react-helmet](https://github.com/nfl/react-helmet#server-usage),\n* Стили через [стайлед-компонентс](https://www.styled-components.com/docs/advanced#server-side-rendering).\n\nДавайте напишем код, который это делает.\n\n```html\n// public/index.html\n\n<!doctype html>\n<html lang=\"ru\">\n\n<head>\n  <meta charset=\"utf-8\">\n\n  // заводим плейсхолдеры\n  // куда будем рендерить стили\n  // и мета-инфу из helmet\n  <meta name=\"$helmet-placeholder$\">\n  <meta name=\"$sc-placeholder$\">\n\n  <style>\n    // скроем, чтобы люди не видели {ssrData}\n\n    .ssr-placeholder {\n      opacity: 0;\n    }\n  </style>\n</head>\n\n<body>\n  <noscript>\n    Сайт без Джаваскрипта работает плохо\n  </noscript>\n\n  <div id=\"root\">\n    // плейсхолдер для основной вёрстки\n    <span class=\"ssr-placeholder\">{ssrData}</span>\n  </div>\n</body>\n\n</html>\n```\n\n```js\n// server/reactApp.js\n// нельзя импортить через require,\n// потому что мы там экспортим через `export`,\n// а не `module.exports` из CommonJS\nimport ReactApp from \"./src/App\";\n\nconst path = require(\"path\");\nconst fs = require(\"fs\");\n\nconst React = require(\"react\");\nconst { StaticRouter } = require(\"react-router-dom\");\nconst ReactDOMServer = require(\"react-dom/server\");\n\nconst { Helmet } = require(\"react-helmet\");\nconst { ServerStyleSheet } = require(\"styled-components\");\n\n// берём build/index.html и сохраняем весь контент в indexFileContent\nconst indexFile = path.resolve(__dirname, \"..\", \"build\", \"index.html\");\nconst indexFileContent = fs.readFileSync(indexFile, { encoding: \"utf8\" });\n\n// плейсхолдер куда будем рендерить данные\nconst ssrPlaceholder = '<span class=\"ssr-placeholder\">{ssrData}</span>';\n\n// плейсхолдер для react-helmet\nconst helmetPlaceholder = '<meta name=\"$helmet-placeholder$\">';\n\n// плейсхолдер для styled-components\nconst scPlaceholder = '<meta name=\"$sc-placeholder$\">';\n\nmodule.exports = (req, res) => {\n  // https://www.styled-components.com/docs/advanced#server-side-rendering\n  // получаем стили\n  const sheet = new ServerStyleSheet();\n\n  // https://reacttraining.com/react-router/web/guides/server-rendering\n  const context = {};\n\n  // приложение с роутером\n  const AppWithRouter = (\n    <StaticRouter location={req.url} context={context}>\n      <ReactApp />\n    </StaticRouter>\n  );\n\n  // получим стили для текущей страницы\n  const AppWithStyles = sheet.collectStyles(AppWithRouter);\n\n  // рендерим в строку\n  const App = ReactDOMServer.renderToString(AppWithStyles);\n\n  // https://github.com/nfl/react-helmet#server-usage\n  // все данные из helmet переводим в строку\n  // и получаем <style> для стайлед-компонентс\n  const helmet = Helmet.renderStatic();\n  const styleTags = sheet.getStyleTags();\n\n  // редиректим с http-кодом 301\n  // если где-то есть <Redirect /> реакт-роутера\n  if (context.url) res.redirect(301, context.url);\n\n  // собираем title, meta, link-теги\n  // в одну строку\n  const helmetData = `\n    ${helmet.title.toString()}\n    ${helmet.meta.toString()}\n    ${helmet.link.toString()}\n  `;\n\n  // вставляем данные через функцию replace\n  // в indexFileContent заменяем все плейсхолдеры\n  const content = indexFileContent\n    .replace(helmetPlaceholder, helmetData)\n    .replace(scPlaceholder, styleTags)\n    .replace(ssrPlaceholder, App);\n\n  // возвращаем тело запроса\n  res.send(content);\n};\n```\n\nИ пишем небольшой сервер на Экспрессе\n\n```js\n// server/index.js\n\n// используем npm.im/debug вместо консольлогов\nconst debug = require(\"debug\")(\"erodionov:server\");\nconst express = require(\"express\");\nconst path = require(\"path\");\n\n// импортим нашу функцию\nconst handleRenderReactApp = require(\"./reactApp\");\n\nconst server = express();\n\n// достаём HOST и PORT энв-параметрами\n// если их нет — ставим дефолтные значения\nconst { HOST = \"127.0.0.1\", PORT = 8080 } = process.env;\n\n// статикой раздаём директорию `build`\n// для картинок и прочего\n// и выключаем через { index: false } использование\n// файла build/index.html\n// иначе Экспресс будет отдавать его на /\nserver.use(\n  express.static(path.resolve(__dirname, \"..\", \"build\"), { index: false })\n);\n\n// на любой запрос вызываем функцию handleRenderReactApp\nserver.get(\"/*\", handleRenderReactApp);\n\nserver.listen(PORT, HOST, () => debug(`app started at ${HOST}:${PORT}`));\n```\n\nЗапускаем как `PUBLIC_URL=https://erodionov.ru babel-node server/index.js` и вуаля, всё работает!\n\n## Итог\n\nДа, серверный рендеринг это и легко и сложно одновременно: что-то могло быть легче, но в целом это не какая-то шаманская магия, всё вполне очевидно решается.\n\nНу и заодно мы в начале урока разобрались с ХТТП и Нодой!\n\n> PS: публичный код этого сервернего рендеринга я храню в [gist.github.com](https://gist.github.com/evgenyrodionov/d29ab267c2c18d16b37377ca6c30232b)\n","id":"HpQvjr5ieg","stageId":"tHKYMIR4QG"}