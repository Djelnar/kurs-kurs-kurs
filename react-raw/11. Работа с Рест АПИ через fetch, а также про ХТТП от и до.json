{"stage":2,"title":"Работа с Рест АПИ через fetch, а также про ХТТП от и до","subTitle":"Как брать данные, где брать данные и что такое асинхронное программирование","markdown":"# Про ХТТП\n\n<iframe width=\"100%\" height=\"541\" src=\"https://www.youtube.com/embed/WzjDqrS22Jg\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe>\n\nЕсли вы читали [второй урок](https://erodionov.ru/courses/verstka/FhTKluFzm7/nHdviS9Jil) курса по вёрстке, то вы помните, что весь интернет работает на ХТТП, связке \"клиенты-сервер\" и, конечно, запросах с ответами.\n\n## ХТТП\n\nХТТП это протокол передачи данных: мы отправляем к серверу запрос и получаем ответ.\n\nМы — это клиент, а клиентом может быть хоть `wget` или `curl` из Терминала, хоть браузер. Хоть микроволновка на Андроиде.\n\nКак выглядит запрос? У него есть адрес и метод: `GET`, `POST`, `PUT`, `DELETE`, `PATCH`, `OPTIONS` — вы делаете запрос на адрес и указываете метод.\n\nЗачем это нужно? У каждого **ресурса** может быть поддержка нескольких методов: например, на `POST /users` создаётся новый пользователь, а на `GET` — запрашивается список.\n\n- `GET` — запросить данные,\n- `POST` — создать новую **сущность**,\n- `PUT` — обновить существующую,\n- `DELETE` — удалить её,\n- `PATCH` — частично обновить,\n- `OPTIONS` — доступные опции у ресурса\n\nПримеры?\n\n- `GET /users` — запросить список пользователей,\n- `POST /users` — создать пользователя,\n- `PUT /users/evgenyrodionov` — обновить пользователя `evgenyrodionov`,\n- `PATCH /users/evgenyrodionov` — частично обновить пользователя `evgenyrodionov`,\n- `OPTIONS /users` — запросить опции, доступные на ресурсе (допустим, параметры фильтрации).\n\nЕсть много вопросов, давайте на них отвечу. Начнём снизу.\n\n### Как передавать параметры\n\nДля этого есть кверипарамс (query params) — это те параметры, которые указываются у адреса, например, `GET /users?state=active&offset=20&courseId=react`\n\nКверипарамс это всего лишь строка в формате `key=value` и объединением через `&`.\n\nВ джсе легче всего работать через пакет [`qs`](https://npm.im/qs) — он преобразовывает кверипарамс в объект и обратно.\n\n### В чём отличие PATCH от PUT\n\nВ `PUT` уходит новый объект, а в `PATCH` — список изменений.\n\n### А как это передавать\n\nДля этого есть **тело запроса**, обычно это Джаваскрипт объект (или JSON).\n\n```\nPOST /users\n\n{\n  \"username\": \"evgenyrodionov\",\n  \"email\": \"kurs@erodionov.ru\",\n  \"age\": 24\n}\n```\n\nДля Джсона используется контент-тайп `application/json`, но бывают ещё `multipart/form-data` (раньше для форм, сейчас в основном для файлов). Что это такое? Это [майм-типы](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types).\n\n### А как их указывать\n\nДля этого используется заголовок `content-type: application/json`.\n\n### Заголовок?\n\nДа, у каждого запроса есть [**заголовки**](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers) — это служебная информация для сервера, которую не стоит пихать в тело запроса.\n\nВот основные:\n\n- `content-type` — тип тела,\n- `accept` — в чём обрабатывается ответ (тоже майм-тип),\n- `cookie` — [куки](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies),\n- `authorization` — авторизационные данные (например, логин и зашифрованный пароль)\n\nОбычно разработчик работает с этими заголовками.\n\n### А есть заголовки ответа?\n\nДа.\n\n### Например?\n\nОдин из самых основных это `status`.\n\nСтатус это [**код** ответа](https://httpstatuses.com/), по которому можно определить насколько успешно прошёл запрос. Кодов много, но вот основные:\n\n#### 2xx\n\nЭто успешные коды ответа.\n\n- [200 OK](https://httpstatuses.com/200) — сервер обработал запрос,\n- [201 Created](https://httpstatuses.com/201) — создан новый ресурс,\n- [204 No Content](https://httpstatuses.com/204) — сервер обработал запрос, но ему нечего прислать в теле.\n\n#### 3xx\n\nОтвечают за редиректы, нужен заголовок `location` с новым адресом.\n\n- [301 Moved Permanently](https://httpstatuses.com/301) — ресурс навсегда переехал,\n- [302 Found](https://httpstatuses.com/302) — ресурс временно находится по другому адресу.\n\n#### 4xx\n\nЗапрос был отправлен с ошибкой на стороне клиента (например, неправильно поле заполнено).\n\n- [400 Bad Request](https://httpstatuses.com/400) — общая ошибка и не очень понятная,\n- [401 Unauthorized](https://httpstatuses.com/401) — человек не авторизован,\n- [403 Forbidden](https://httpstatuses.com/403) — нет доступа,\n- [404 Not Found](https://httpstatuses.com/404) — ресурс или сущность не найдены.\n\n#### 5xx\n\nПроблемы на стороне сервера.\n\n- [500 Internal Server Error](https://httpstatuses.com/500) — такая же общая и слабо понятная ошибка, как 400,\n- [501 Not Implemented](https://httpstatuses.com/501) — ресурс не реализован,\n- [502 Bad Gateway](https://httpstatuses.com/502) — плохой ответ,\n- [503 Service Unavailable](https://httpstatuses.com/503) — сервис временно недоступен, полезно отправить заголовок [`retry-after`](https://tools.ietf.org/html/rfc7231#section-7.1.3) с времнем в секундах,\n- [504 Gateway Timeout](https://httpstatuses.com/504) — ответ не был получен вовремя.\n\n---\n\nСуммируем.\n\nВеб работает на протоколе ХТТП по системе \"клиент-сервер\": клиент посылает запрос на адрес, сервер присылает ответ.\n\nКлиент может передать заголовки и тело, а сервер может прислать заголовки и тело.\n\nКлиент это любой инструмент, который работает с ХТТП — хоть другой сервер, хоть утилита в Терминале, хоть бот в Телеграме.\n\nНо как со всем этим работать во фронтэнде?\n\n## Рест АПИ\n\nВы часто, наверное, слышите про Рест АПИ — мол, наш АПИ он РЕСТФул, мол, полностью по стандартам.\n\nИрония в том, что любой АПИ, построенный на ХТТП, будет рестовым — в этом и смысл ХТТП. Посмотрите на это определение из Википедии:\n\n> REpresentational State Transfer (_REST_), or RESTful, web services provide interoperability between computer systems on the Internet\n\nВ мире нет единого стандарта построения АПИ бэкэнда — каждый дрочит, как он хочет. Нет, серьёзно, посмотрите на эту тьму гайдлайнов: [HackerNoon](https://hackernoon.com/restful-api-designing-guidelines-the-best-practices-60e1d954e7c9), [studioarmix](https://medium.com/studioarmix/learn-restful-api-design-ideals-c5ec915a430f), [Некий Филип](https://blog.philipphauer.de/restful-api-design-best-practices/), [Майкрософт](https://github.com/Microsoft/api-guidelines), [Гугл](https://cloud.google.com/apis/design/), [RestCase](http://blog.restcase.com/5-basic-rest-api-design-guidelines/). Тысячи их!\n\nМне больше всего нравятся [архитектура и документация](https://stripe.com/docs/api) у Страйпа — это эквайринг для приёма платежей. Почитайте как-нибудь.\n\n## Асинхронность, лайфсайклы и фетч\n\n<iframe width=\"100%\" height=\"541\" src=\"https://www.youtube.com/embed/ATYQtAjOgHE\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe>\n\n### Фетч\n\nРаньше был [XMLHttpRequest](https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest) — браузерный АПИ для запросов. Неудобный аж жуть.\n\nПоэтому когда появился Джквери с его функцией `$.ajax()`, люди выдохнули: наконец-то удобный способ для работы с ХТТП.\n\nЧестно говоря, это было одним из поворотных событий, которое привело нас к так называемому Вебу 2.0: интерактивному и без перезагрузок страниц. Веб стал больше похож на приложения, чем на сайты.\n\nЗатем этот подход забрали себе библиотеки [axios](https://github.com/axios/axios) и [superagent](https://github.com/visionmedia/superagent).\n\nНу а позже появился новый браузерный АПИ [fetch](https://developer.mozilla.org/en/docs/Web/API/Fetch_API) — сейчас его многие и используют. Если нужна поддержка старых браузеров — берут полифилл [github/fetch](https://github.github.io/fetch/) от Гитхаба.\n\nСобственно, Фетч. Фетч это АПИ браузера, которое работает с ХТТП: вы делаете запрос на адрес и обрабатываете ответ.\n\nЧисто технически, это просто одна функция `fetch()`, которая построена на промисах. То есть на чём? Об этом позже.\n\nВ Фетч вы передаёте адрес и опции: от заголовков до тела запроса, вот пример —\n\n```js\nconst data = {\n  username: \"evgenyrodionov\",\n  email: \"kurs@erodionov.ru\",\n  age: 24\n};\n\nfetch(\"/api/v1/users\", {\n  method: \"POST\", // метод\n  body: JSON.stringify(data), // тело\n  // заголовки\n  headers: {\n    \"Content-Type\": \"application/json\"\n  },\n  // работа с куки\n  credentials: \"same-origin\"\n})\n  .then(\n    function(response) {\n      // https://github.github.io/fetch/#Response\n      console.log(response.status); //=> number 100–599\n      console.log(response.statusText); //=> String\n      console.log(response.headers); //=> Headers\n      console.log(response.url); //=> String\n\n      return response.json();\n    },\n    function(error) {\n      error.message; //=> String\n    }\n  )\n  .then(function(responseAsJson) {\n    console.log(responseAsJson);\n    //  {\n    //    \"id\": 1, // новое поле, потому что пользователь успешно создан\n    //    \"username\": \"evgenyrodionov\",\n    //    \"email\": \"kurs@erodionov.ru\",\n    //    \"age\": 24\n    //  }\n  });\n```\n\nОкей, запрос понятен, вроде даже ответ как-то обрабатываем в функции, которую передаём в `.then`. Кстати, а что за `.then`?\n\n#### Асинхронное программирование\n\nНа этом моменте мы узнаем интересный аспект: бывают синхронное и асинхронное программирование. К плаванью отношения не имеют.\n\nСинхронное программирование это когда интерпретатор код выполняет строчка за строчкой:\n\n```js\nconst x = 1;\n\nconsole.log(x); // 1\n```\n\nВ асинхронном программировании мы не знаем, когда выполнится наша функция: то ли сразу же, то ли через 10 мс, то ли через 50 секунд, то ли через 20 минут. И как быть? Как с этим работать?\n\nСуществуют три способа.\n\n##### Коллбэки\n\nКоллбэки (callbacks) это простая функция, которая вызывается, когда выполнится функция, которую вы вызвали.\n\nВы знали, что `setState()` [асинхронный](https://reactjs.org/docs/react-component.html#setstate)? Если вы попробуете обратиться к стейту на следующей строчке после вызова `setState()`, вы можете удивиться, когда увидите старые данные.\n\n```js\nimport React from \"react\";\n\nclass Counter extends React.Component {\n  state = {\n    counter: 0\n  };\n\n  handleClick = () => {\n    this.setState({ counter: this.state.counter + 1 });\n    console.log(this.state); // 0\n  };\n\n  render() {\n    return (\n      <React.Fragment>\n        <pre>{JSON.stringify(this.state, null, 2)}</pre>\n        <button onClick={this.handleClick}>+</button>\n      </React.Fragment>\n    );\n  }\n}\n```\n\n<iframe src=\"https://codesandbox.io/embed/0mqo1ol5yl\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\nВозможно, вы и не увидите этого: смысл ведь не в том, что запрос выполняется с задержкой, а в том, что неизвестно время получения результата.\n\nПочему `setState` асинхронный? Потому что бывает, что Реакт накапливает вызовы и потом разом обновляет стейт: так производительнее.\n\nКак с этим работать? Обращайтесь к стейту в коллбеке.\n\n```js\nthis.setState({ counter: this.state.counter + 1 }, function() {\n  console.log(this.state); // 1\n});\n```\n\nКоллбек это функция, которая передаётся аргументом и вызывается, когда код отработан. Пример:\n\n```js\nfunction multiplyNumber(number, cb) {\n  const multiplied = number * number;\n\n  cb(multiplied);\n}\n\nconsole.log(multiplyNumber(2)); // undefined, потому что нет return в функции\n\nmultiplyNumber(2, function(result) {\n  console.log(result); // 4\n});\n```\n\n##### Промисы\n\nПромисы (Promises) это обещания. Чисто технически, это те же коллбеки, но на стероидах: вместо аргумента мы используем методы `.then()` и `.catch()` у функции-промиса. Фетч работает на промисах. В методы мы передаём функцию.\n\n```js\nfetch(url, params)\n  .then(function(response) {\n    console.log(response);\n  })\n  .catch(function(error) {\n    console.log(error);\n  });\n```\n\n##### Асинк-эвейт\n\nВ 2017 году в Экмаскрипт (стандарт, на котором работает Джаваскрипт) привезли новую фичу: `async-await` — способ писать в синхронном стиле асинхронный код.\n\nАсинк-эвейты работают вместо промисов в том числе.\n\n```js\nconst response = await fetch(url, params);\n\nconsole.log(response);\n```\n\nА как работать с ошибками? Через конструкцию `try..catch`:\n\n```js\ntry {\n  const response = await fetch(url, params);\n\n  console.log(response);\n} catch (error) {\n  console.log(error);\n}\n```\n\nВсегда обрабатывайте ошибки! Даже если знаете, что придут \"чистые\" данные: я так понадеялся на Телеграм и однажды свалил сайт на полчаса, потому что Телеграм стал присылать ошибку, которую я не обрабатывал — из-за этого падал весь бэкэнд.\n\nКогда он перезапускался, то заново пытался выполнить и терпел неудачу, снова падая. С тех пор у меня весь код в `try..catch`.\n\n---\n\nРезюмируя: для ХТТП-запросов мы используем Фетч, который работает асинхронно.\n\nВ асинхронном программировании мы не знаем, когда придёт результат, поэтому пишем функцию, которая вызовется, когда он всё-таки придёт.\n\nДля асинхронного программирования есть три подхода в Джс: коллбэки, промисы и асинк-эвейт. Чтобы не было проблем и не бегать с горящей жопой, всегда нужно ловить ошибки и их обрабатывать: либо для себя выводить, либо использовать сервис тип Сентри или Багснега, либо показать ошибку пользователю.\n\nКстати, асинхронное программирование нужно, чтобы не блокировать основной **поток** исполнения кода: представьте, как бы вас бесил интерфейс, если бы он замерзал (даже скроллить нельзя!) пока не получил ответ или не обновил стейт. Ужасно же.\n\n## Итог\n\nСегодня мы прошлись по устройству ХТТП, узнали про асинхронное программирование, коллбэки, промисы и асинк-эвейты и Фетч, который работает на последних двух подходах.\n\nИ помните: всегда обрабатывайте ошибки. Это чертовски важно, хоть и рутинно сложно. Лучше пользователь увидит непонятное \"произошла ошибка\", чем не поймёт что произошло. А ещё лучше, если он узнает на чьей она стороне и что он может с этим сделать.\n","id":"bhWxD2rQV1","stageId":"rHAh7OXEFL"}